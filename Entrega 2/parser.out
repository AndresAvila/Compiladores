Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque
Rule 2     createProcedureDir -> <empty>
Rule 3     addProcedureDir -> <empty>
Rule 4     cicloVars -> vars cicloVars
Rule 5     cicloVars -> <empty>
Rule 6     vars -> createVariableDir VAR auxVar1
Rule 7     createVariableDir -> <empty>
Rule 8     auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1
Rule 9     auxVar1 -> <empty>
Rule 10    addTypeGlobal -> <empty>
Rule 11    idVars -> addVariableDir ID ambIdVars
Rule 12    addVariableDir -> <empty>
Rule 13    ambIdVars -> COMMA idVars
Rule 14    ambIdVars -> <empty>
Rule 15    tipo -> auxTipo1
Rule 16    tipo -> CHAR
Rule 17    auxTipo1 -> auxTipo2 LBRACKET CTEINT RBRACKET
Rule 18    auxTipo1 -> auxTipo2
Rule 19    auxTipo2 -> INT
Rule 20    auxTipo2 -> BOOL
Rule 21    auxTipo2 -> STRING
Rule 22    auxTipo2 -> FLOAT
Rule 23    bloque -> LBRACE cicloBloque RBRACE
Rule 24    cicloBloque -> estatuto cicloBloque
Rule 25    cicloBloque -> <empty>
Rule 26    estatuto -> asignacion
Rule 27    estatuto -> condicion
Rule 28    estatuto -> escritura
Rule 29    estatuto -> lectura
Rule 30    estatuto -> llamada
Rule 31    estatuto -> ciclo
Rule 32    asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON
Rule 33    auxAsignacion1 -> LBRACKET exp RBRACKET
Rule 34    auxAsignacion1 -> <empty>
Rule 35    escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
Rule 36    auxEscritura1 -> auxEscritura2 ambAuxEscritura1
Rule 37    ambAuxEscritura1 -> COMMA auxEscritura1
Rule 38    ambAuxEscritura1 -> <empty>
Rule 39    auxEscritura2 -> exp
Rule 40    auxEscritura2 -> CTESTRING
Rule 41    expresion -> exp auxExpresion exp
Rule 42    expresion -> <empty>
Rule 43    auxExpresion -> GTHAN
Rule 44    auxExpresion -> LTHAN
Rule 45    auxExpresion -> NOTEQUAL
Rule 46    auxExpresion -> GETHAN
Rule 47    auxExpresion -> LETHAN
Rule 48    auxExpresion -> EQUAL
Rule 49    condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON
Rule 50    auxCondicion -> ELSE bloque
Rule 51    auxCondicion -> <empty>
Rule 52    exp -> cicloExp
Rule 53    cicloExp -> termino ambExp
Rule 54    ambExp -> auxExp cicloExp
Rule 55    ambExp -> <empty>
Rule 56    auxExp -> PLUS
Rule 57    auxExp -> MINUS
Rule 58    termino -> cicloTermino
Rule 59    cicloTermino -> factor ambCicloTermino
Rule 60    ambCicloTermino -> auxTermino cicloTermino
Rule 61    ambCicloTermino -> <empty>
Rule 62    auxTermino -> MULTI
Rule 63    auxTermino -> DIVIDE
Rule 64    factor -> LPAREN expresion RPAREN
Rule 65    factor -> auxFactor varcte
Rule 66    auxFactor -> auxExp
Rule 67    auxFactor -> <empty>
Rule 68    varcte -> ID auxVarcte
Rule 69    varcte -> CTEINT
Rule 70    varcte -> CTEFLOAT
Rule 71    varcte -> CTECHAR
Rule 72    varcte -> CTEBOOL
Rule 73    varcte -> CTESTRING
Rule 74    auxVarcte -> LPAREN exp RPAREN
Rule 75    auxVarcte -> LBRACKET exp LBRACKET
Rule 76    auxVarcte -> <empty>
Rule 77    cicloFuncion -> funcion cicloFuncion
Rule 78    cicloFuncion -> <empty>
Rule 79    funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque
Rule 80    addProcDirectoryFunc -> <empty>
Rule 81    auxFunction -> parametros
Rule 82    auxFunction -> <empty>
Rule 83    parametros -> auxParametros
Rule 84    auxParametros -> tipo ID ambAuxParametros
Rule 85    ambAuxParametros -> COMMA auxParametros
Rule 86    ambAuxParametros -> <empty>
Rule 87    ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON
Rule 88    llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON
Rule 89    auxLlamada -> argumentos
Rule 90    auxLlamada -> <empty>
Rule 91    argumentos -> auxArgumentos1
Rule 92    argumentos -> <empty>
Rule 93    auxArgumentos1 -> exp ambAuxArgumentos1
Rule 94    ambAuxArgumentos1 -> COMMA auxArgumentos1
Rule 95    ambAuxArgumentos1 -> <empty>
Rule 96    lectura -> READ LPAREN ID RPAREN SEMICOLON

Terminals, with rules where they appear

BOOL                 : 20
CHAR                 : 16
COLON                : 8
COMMA                : 13 37 85 94
CTEBOOL              : 72
CTECHAR              : 71
CTEFLOAT             : 70
CTEINT               : 17 69
CTESTRING            : 40 73
DIVIDE               : 63
ELSE                 : 50
EQUAL                : 48
EQUALA               : 32
FLOAT                : 22
FUNCTION             : 79
GETHAN               : 46
GTHAN                : 43
ID                   : 1 11 32 68 79 84 88 96
IF                   : 49
INT                  : 19
LBRACE               : 23
LBRACKET             : 17 33 75 75
LETHAN               : 47
LPAREN               : 35 49 64 74 79 87 88 96
LTHAN                : 44
MINUS                : 57
MULTI                : 62
NOTEQUAL             : 45
PLUS                 : 56
PRINT                : 35
PROGRAM              : 1
RBRACE               : 23
RBRACKET             : 17 33
READ                 : 96
RPAREN               : 35 49 64 74 79 87 88 96
SEMICOLON            : 1 8 32 35 49 87 88 96
STRING               : 21
VAR                  : 6
WHILE                : 87
error                : 

Nonterminals, with rules where they appear

addProcDirectoryFunc : 79
addProcedureDir      : 1
addTypeGlobal        : 8
addVariableDir       : 11
ambAuxArgumentos1    : 93
ambAuxEscritura1     : 36
ambAuxParametros     : 84
ambCicloTermino      : 59
ambExp               : 53
ambIdVars            : 11
argumentos           : 89
asignacion           : 26
auxArgumentos1       : 91 94
auxAsignacion1       : 32
auxCondicion         : 49
auxEscritura1        : 35 37
auxEscritura2        : 36
auxExp               : 54 66
auxExpresion         : 41
auxFactor            : 65
auxFunction          : 79
auxLlamada           : 88
auxParametros        : 83 85
auxTermino           : 60
auxTipo1             : 15
auxTipo2             : 17 18
auxVar1              : 6 8
auxVarcte            : 68
bloque               : 1 49 50 79 87
ciclo                : 31
cicloBloque          : 23 24
cicloExp             : 52 54
cicloFuncion         : 1 77
cicloTermino         : 58 60
cicloVars            : 1 4
condicion            : 27
createProcedureDir   : 1
createVariableDir    : 6
escritura            : 28
estatuto             : 24
exp                  : 32 33 39 41 41 74 75 93
expresion            : 49 64 87
factor               : 59
funcion              : 77
idVars               : 8 13
lectura              : 29
llamada              : 30
parametros           : 81
programa             : 0
termino              : 53
tipo                 : 8 79 84
varcte               : 65
vars                 : 4

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque

    PROGRAM         shift and go to state 1

    programa                       shift and go to state 2

state 1

    (1) programa -> PROGRAM . createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque
    (2) createProcedureDir -> .

    ID              reduce using rule 2 (createProcedureDir -> .)

    createProcedureDir             shift and go to state 3

state 2

    (0) S' -> programa .



state 3

    (1) programa -> PROGRAM createProcedureDir . addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque
    (3) addProcedureDir -> .

    ID              reduce using rule 3 (addProcedureDir -> .)

    addProcedureDir                shift and go to state 4

state 4

    (1) programa -> PROGRAM createProcedureDir addProcedureDir . ID SEMICOLON cicloVars cicloFuncion bloque

    ID              shift and go to state 5


state 5

    (1) programa -> PROGRAM createProcedureDir addProcedureDir ID . SEMICOLON cicloVars cicloFuncion bloque

    SEMICOLON       shift and go to state 6


state 6

    (1) programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON . cicloVars cicloFuncion bloque
    (4) cicloVars -> . vars cicloVars
    (5) cicloVars -> .
    (6) vars -> . createVariableDir VAR auxVar1
    (7) createVariableDir -> .

    CHAR            reduce using rule 5 (cicloVars -> .)
    INT             reduce using rule 5 (cicloVars -> .)
    BOOL            reduce using rule 5 (cicloVars -> .)
    STRING          reduce using rule 5 (cicloVars -> .)
    FLOAT           reduce using rule 5 (cicloVars -> .)
    LBRACE          reduce using rule 5 (cicloVars -> .)
    VAR             reduce using rule 7 (createVariableDir -> .)

    vars                           shift and go to state 7
    cicloVars                      shift and go to state 8
    createVariableDir              shift and go to state 9

state 7

    (4) cicloVars -> vars . cicloVars
    (4) cicloVars -> . vars cicloVars
    (5) cicloVars -> .
    (6) vars -> . createVariableDir VAR auxVar1
    (7) createVariableDir -> .

    CHAR            reduce using rule 5 (cicloVars -> .)
    INT             reduce using rule 5 (cicloVars -> .)
    BOOL            reduce using rule 5 (cicloVars -> .)
    STRING          reduce using rule 5 (cicloVars -> .)
    FLOAT           reduce using rule 5 (cicloVars -> .)
    LBRACE          reduce using rule 5 (cicloVars -> .)
    VAR             reduce using rule 7 (createVariableDir -> .)

    createVariableDir              shift and go to state 9
    cicloVars                      shift and go to state 10
    vars                           shift and go to state 7

state 8

    (1) programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars . cicloFuncion bloque
    (77) cicloFuncion -> . funcion cicloFuncion
    (78) cicloFuncion -> .
    (79) funcion -> . tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque
    (15) tipo -> . auxTipo1
    (16) tipo -> . CHAR
    (17) auxTipo1 -> . auxTipo2 LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> . auxTipo2
    (19) auxTipo2 -> . INT
    (20) auxTipo2 -> . BOOL
    (21) auxTipo2 -> . STRING
    (22) auxTipo2 -> . FLOAT

    LBRACE          reduce using rule 78 (cicloFuncion -> .)
    CHAR            shift and go to state 11
    INT             shift and go to state 16
    BOOL            shift and go to state 13
    STRING          shift and go to state 15
    FLOAT           shift and go to state 17

    tipo                           shift and go to state 12
    cicloFuncion                   shift and go to state 18
    auxTipo2                       shift and go to state 20
    auxTipo1                       shift and go to state 19
    funcion                        shift and go to state 14

state 9

    (6) vars -> createVariableDir . VAR auxVar1

    VAR             shift and go to state 21


state 10

    (4) cicloVars -> vars cicloVars .

    CHAR            reduce using rule 4 (cicloVars -> vars cicloVars .)
    INT             reduce using rule 4 (cicloVars -> vars cicloVars .)
    BOOL            reduce using rule 4 (cicloVars -> vars cicloVars .)
    STRING          reduce using rule 4 (cicloVars -> vars cicloVars .)
    FLOAT           reduce using rule 4 (cicloVars -> vars cicloVars .)
    LBRACE          reduce using rule 4 (cicloVars -> vars cicloVars .)


state 11

    (16) tipo -> CHAR .

    ID              reduce using rule 16 (tipo -> CHAR .)
    FUNCTION        reduce using rule 16 (tipo -> CHAR .)
    SEMICOLON       reduce using rule 16 (tipo -> CHAR .)


state 12

    (79) funcion -> tipo . FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque

    FUNCTION        shift and go to state 22


state 13

    (20) auxTipo2 -> BOOL .

    LBRACKET        reduce using rule 20 (auxTipo2 -> BOOL .)
    FUNCTION        reduce using rule 20 (auxTipo2 -> BOOL .)
    ID              reduce using rule 20 (auxTipo2 -> BOOL .)
    SEMICOLON       reduce using rule 20 (auxTipo2 -> BOOL .)


state 14

    (77) cicloFuncion -> funcion . cicloFuncion
    (77) cicloFuncion -> . funcion cicloFuncion
    (78) cicloFuncion -> .
    (79) funcion -> . tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque
    (15) tipo -> . auxTipo1
    (16) tipo -> . CHAR
    (17) auxTipo1 -> . auxTipo2 LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> . auxTipo2
    (19) auxTipo2 -> . INT
    (20) auxTipo2 -> . BOOL
    (21) auxTipo2 -> . STRING
    (22) auxTipo2 -> . FLOAT

    LBRACE          reduce using rule 78 (cicloFuncion -> .)
    CHAR            shift and go to state 11
    INT             shift and go to state 16
    BOOL            shift and go to state 13
    STRING          shift and go to state 15
    FLOAT           shift and go to state 17

    tipo                           shift and go to state 12
    cicloFuncion                   shift and go to state 23
    auxTipo1                       shift and go to state 19
    auxTipo2                       shift and go to state 20
    funcion                        shift and go to state 14

state 15

    (21) auxTipo2 -> STRING .

    LBRACKET        reduce using rule 21 (auxTipo2 -> STRING .)
    FUNCTION        reduce using rule 21 (auxTipo2 -> STRING .)
    ID              reduce using rule 21 (auxTipo2 -> STRING .)
    SEMICOLON       reduce using rule 21 (auxTipo2 -> STRING .)


state 16

    (19) auxTipo2 -> INT .

    LBRACKET        reduce using rule 19 (auxTipo2 -> INT .)
    FUNCTION        reduce using rule 19 (auxTipo2 -> INT .)
    ID              reduce using rule 19 (auxTipo2 -> INT .)
    SEMICOLON       reduce using rule 19 (auxTipo2 -> INT .)


state 17

    (22) auxTipo2 -> FLOAT .

    LBRACKET        reduce using rule 22 (auxTipo2 -> FLOAT .)
    FUNCTION        reduce using rule 22 (auxTipo2 -> FLOAT .)
    ID              reduce using rule 22 (auxTipo2 -> FLOAT .)
    SEMICOLON       reduce using rule 22 (auxTipo2 -> FLOAT .)


state 18

    (1) programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion . bloque
    (23) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 25

    bloque                         shift and go to state 24

state 19

    (15) tipo -> auxTipo1 .

    ID              reduce using rule 15 (tipo -> auxTipo1 .)
    FUNCTION        reduce using rule 15 (tipo -> auxTipo1 .)
    SEMICOLON       reduce using rule 15 (tipo -> auxTipo1 .)


state 20

    (17) auxTipo1 -> auxTipo2 . LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> auxTipo2 .

    LBRACKET        shift and go to state 26
    FUNCTION        reduce using rule 18 (auxTipo1 -> auxTipo2 .)
    ID              reduce using rule 18 (auxTipo1 -> auxTipo2 .)
    SEMICOLON       reduce using rule 18 (auxTipo1 -> auxTipo2 .)


state 21

    (6) vars -> createVariableDir VAR . auxVar1
    (8) auxVar1 -> . idVars COLON addTypeGlobal tipo SEMICOLON auxVar1
    (9) auxVar1 -> .
    (11) idVars -> . addVariableDir ID ambIdVars
    (12) addVariableDir -> .

    VAR             reduce using rule 9 (auxVar1 -> .)
    CHAR            reduce using rule 9 (auxVar1 -> .)
    INT             reduce using rule 9 (auxVar1 -> .)
    BOOL            reduce using rule 9 (auxVar1 -> .)
    STRING          reduce using rule 9 (auxVar1 -> .)
    FLOAT           reduce using rule 9 (auxVar1 -> .)
    LBRACE          reduce using rule 9 (auxVar1 -> .)
    ID              reduce using rule 12 (addVariableDir -> .)

    idVars                         shift and go to state 27
    addVariableDir                 shift and go to state 28
    auxVar1                        shift and go to state 29

state 22

    (79) funcion -> tipo FUNCTION . addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque
    (80) addProcDirectoryFunc -> .

    ID              reduce using rule 80 (addProcDirectoryFunc -> .)

    addProcDirectoryFunc           shift and go to state 30

state 23

    (77) cicloFuncion -> funcion cicloFuncion .

    LBRACE          reduce using rule 77 (cicloFuncion -> funcion cicloFuncion .)


state 24

    (1) programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque .

    $end            reduce using rule 1 (programa -> PROGRAM createProcedureDir addProcedureDir ID SEMICOLON cicloVars cicloFuncion bloque .)


state 25

    (23) bloque -> LBRACE . cicloBloque RBRACE
    (24) cicloBloque -> . estatuto cicloBloque
    (25) cicloBloque -> .
    (26) estatuto -> . asignacion
    (27) estatuto -> . condicion
    (28) estatuto -> . escritura
    (29) estatuto -> . lectura
    (30) estatuto -> . llamada
    (31) estatuto -> . ciclo
    (32) asignacion -> . ID auxAsignacion1 EQUALA exp SEMICOLON
    (49) condicion -> . IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON
    (35) escritura -> . PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
    (96) lectura -> . READ LPAREN ID RPAREN SEMICOLON
    (88) llamada -> . ID LPAREN auxLlamada RPAREN SEMICOLON
    (87) ciclo -> . WHILE LPAREN expresion RPAREN bloque SEMICOLON

    RBRACE          reduce using rule 25 (cicloBloque -> .)
    ID              shift and go to state 41
    IF              shift and go to state 38
    PRINT           shift and go to state 33
    READ            shift and go to state 31
    WHILE           shift and go to state 32

    ciclo                          shift and go to state 34
    asignacion                     shift and go to state 42
    estatuto                       shift and go to state 35
    llamada                        shift and go to state 36
    condicion                      shift and go to state 37
    cicloBloque                    shift and go to state 40
    lectura                        shift and go to state 39
    escritura                      shift and go to state 43

state 26

    (17) auxTipo1 -> auxTipo2 LBRACKET . CTEINT RBRACKET

    CTEINT          shift and go to state 44


state 27

    (8) auxVar1 -> idVars . COLON addTypeGlobal tipo SEMICOLON auxVar1

    COLON           shift and go to state 45


state 28

    (11) idVars -> addVariableDir . ID ambIdVars

    ID              shift and go to state 46


state 29

    (6) vars -> createVariableDir VAR auxVar1 .

    VAR             reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    CHAR            reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    INT             reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    BOOL            reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    STRING          reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    FLOAT           reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)
    LBRACE          reduce using rule 6 (vars -> createVariableDir VAR auxVar1 .)


state 30

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc . ID LPAREN auxFunction RPAREN bloque

    ID              shift and go to state 47


state 31

    (96) lectura -> READ . LPAREN ID RPAREN SEMICOLON

    LPAREN          shift and go to state 48


state 32

    (87) ciclo -> WHILE . LPAREN expresion RPAREN bloque SEMICOLON

    LPAREN          shift and go to state 49


state 33

    (35) escritura -> PRINT . LPAREN auxEscritura1 RPAREN SEMICOLON

    LPAREN          shift and go to state 50


state 34

    (31) estatuto -> ciclo .

    ID              reduce using rule 31 (estatuto -> ciclo .)
    IF              reduce using rule 31 (estatuto -> ciclo .)
    PRINT           reduce using rule 31 (estatuto -> ciclo .)
    READ            reduce using rule 31 (estatuto -> ciclo .)
    WHILE           reduce using rule 31 (estatuto -> ciclo .)
    RBRACE          reduce using rule 31 (estatuto -> ciclo .)


state 35

    (24) cicloBloque -> estatuto . cicloBloque
    (24) cicloBloque -> . estatuto cicloBloque
    (25) cicloBloque -> .
    (26) estatuto -> . asignacion
    (27) estatuto -> . condicion
    (28) estatuto -> . escritura
    (29) estatuto -> . lectura
    (30) estatuto -> . llamada
    (31) estatuto -> . ciclo
    (32) asignacion -> . ID auxAsignacion1 EQUALA exp SEMICOLON
    (49) condicion -> . IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON
    (35) escritura -> . PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
    (96) lectura -> . READ LPAREN ID RPAREN SEMICOLON
    (88) llamada -> . ID LPAREN auxLlamada RPAREN SEMICOLON
    (87) ciclo -> . WHILE LPAREN expresion RPAREN bloque SEMICOLON

    RBRACE          reduce using rule 25 (cicloBloque -> .)
    ID              shift and go to state 41
    IF              shift and go to state 38
    PRINT           shift and go to state 33
    READ            shift and go to state 31
    WHILE           shift and go to state 32

    ciclo                          shift and go to state 34
    asignacion                     shift and go to state 42
    estatuto                       shift and go to state 35
    llamada                        shift and go to state 36
    condicion                      shift and go to state 37
    cicloBloque                    shift and go to state 51
    lectura                        shift and go to state 39
    escritura                      shift and go to state 43

state 36

    (30) estatuto -> llamada .

    ID              reduce using rule 30 (estatuto -> llamada .)
    IF              reduce using rule 30 (estatuto -> llamada .)
    PRINT           reduce using rule 30 (estatuto -> llamada .)
    READ            reduce using rule 30 (estatuto -> llamada .)
    WHILE           reduce using rule 30 (estatuto -> llamada .)
    RBRACE          reduce using rule 30 (estatuto -> llamada .)


state 37

    (27) estatuto -> condicion .

    ID              reduce using rule 27 (estatuto -> condicion .)
    IF              reduce using rule 27 (estatuto -> condicion .)
    PRINT           reduce using rule 27 (estatuto -> condicion .)
    READ            reduce using rule 27 (estatuto -> condicion .)
    WHILE           reduce using rule 27 (estatuto -> condicion .)
    RBRACE          reduce using rule 27 (estatuto -> condicion .)


state 38

    (49) condicion -> IF . LPAREN expresion RPAREN bloque auxCondicion SEMICOLON

    LPAREN          shift and go to state 52


state 39

    (29) estatuto -> lectura .

    ID              reduce using rule 29 (estatuto -> lectura .)
    IF              reduce using rule 29 (estatuto -> lectura .)
    PRINT           reduce using rule 29 (estatuto -> lectura .)
    READ            reduce using rule 29 (estatuto -> lectura .)
    WHILE           reduce using rule 29 (estatuto -> lectura .)
    RBRACE          reduce using rule 29 (estatuto -> lectura .)


state 40

    (23) bloque -> LBRACE cicloBloque . RBRACE

    RBRACE          shift and go to state 53


state 41

    (32) asignacion -> ID . auxAsignacion1 EQUALA exp SEMICOLON
    (88) llamada -> ID . LPAREN auxLlamada RPAREN SEMICOLON
    (33) auxAsignacion1 -> . LBRACKET exp RBRACKET
    (34) auxAsignacion1 -> .

    LPAREN          shift and go to state 56
    LBRACKET        shift and go to state 54
    EQUALA          reduce using rule 34 (auxAsignacion1 -> .)

    auxAsignacion1                 shift and go to state 55

state 42

    (26) estatuto -> asignacion .

    ID              reduce using rule 26 (estatuto -> asignacion .)
    IF              reduce using rule 26 (estatuto -> asignacion .)
    PRINT           reduce using rule 26 (estatuto -> asignacion .)
    READ            reduce using rule 26 (estatuto -> asignacion .)
    WHILE           reduce using rule 26 (estatuto -> asignacion .)
    RBRACE          reduce using rule 26 (estatuto -> asignacion .)


state 43

    (28) estatuto -> escritura .

    ID              reduce using rule 28 (estatuto -> escritura .)
    IF              reduce using rule 28 (estatuto -> escritura .)
    PRINT           reduce using rule 28 (estatuto -> escritura .)
    READ            reduce using rule 28 (estatuto -> escritura .)
    WHILE           reduce using rule 28 (estatuto -> escritura .)
    RBRACE          reduce using rule 28 (estatuto -> escritura .)


state 44

    (17) auxTipo1 -> auxTipo2 LBRACKET CTEINT . RBRACKET

    RBRACKET        shift and go to state 57


state 45

    (8) auxVar1 -> idVars COLON . addTypeGlobal tipo SEMICOLON auxVar1
    (10) addTypeGlobal -> .

    CHAR            reduce using rule 10 (addTypeGlobal -> .)
    INT             reduce using rule 10 (addTypeGlobal -> .)
    BOOL            reduce using rule 10 (addTypeGlobal -> .)
    STRING          reduce using rule 10 (addTypeGlobal -> .)
    FLOAT           reduce using rule 10 (addTypeGlobal -> .)

    addTypeGlobal                  shift and go to state 58

state 46

    (11) idVars -> addVariableDir ID . ambIdVars
    (13) ambIdVars -> . COMMA idVars
    (14) ambIdVars -> .

    COMMA           shift and go to state 60
    COLON           reduce using rule 14 (ambIdVars -> .)

    ambIdVars                      shift and go to state 59

state 47

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc ID . LPAREN auxFunction RPAREN bloque

    LPAREN          shift and go to state 61


state 48

    (96) lectura -> READ LPAREN . ID RPAREN SEMICOLON

    ID              shift and go to state 62


state 49

    (87) ciclo -> WHILE LPAREN . expresion RPAREN bloque SEMICOLON
    (41) expresion -> . exp auxExpresion exp
    (42) expresion -> .
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    RPAREN          reduce using rule 42 (expresion -> .)
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    expresion                      shift and go to state 63
    auxExp                         shift and go to state 65
    auxFactor                      shift and go to state 66
    termino                        shift and go to state 68
    exp                            shift and go to state 64
    factor                         shift and go to state 70
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 50

    (35) escritura -> PRINT LPAREN . auxEscritura1 RPAREN SEMICOLON
    (36) auxEscritura1 -> . auxEscritura2 ambAuxEscritura1
    (39) auxEscritura2 -> . exp
    (40) auxEscritura2 -> . CTESTRING
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

  ! shift/reduce conflict for CTESTRING resolved as shift
    CTESTRING       shift and go to state 77
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

  ! CTESTRING       [ reduce using rule 67 (auxFactor -> .) ]

    auxEscritura1                  shift and go to state 75
    auxEscritura2                  shift and go to state 76
    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 74
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 51

    (24) cicloBloque -> estatuto cicloBloque .

    RBRACE          reduce using rule 24 (cicloBloque -> estatuto cicloBloque .)


state 52

    (49) condicion -> IF LPAREN . expresion RPAREN bloque auxCondicion SEMICOLON
    (41) expresion -> . exp auxExpresion exp
    (42) expresion -> .
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    RPAREN          reduce using rule 42 (expresion -> .)
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    expresion                      shift and go to state 78
    auxExp                         shift and go to state 65
    auxFactor                      shift and go to state 66
    termino                        shift and go to state 68
    exp                            shift and go to state 64
    factor                         shift and go to state 70
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 53

    (23) bloque -> LBRACE cicloBloque RBRACE .

    CHAR            reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    INT             reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    BOOL            reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    STRING          reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    FLOAT           reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    LBRACE          reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    SEMICOLON       reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    $end            reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)
    ELSE            reduce using rule 23 (bloque -> LBRACE cicloBloque RBRACE .)


state 54

    (33) auxAsignacion1 -> LBRACKET . exp RBRACKET
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 79
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 55

    (32) asignacion -> ID auxAsignacion1 . EQUALA exp SEMICOLON

    EQUALA          shift and go to state 80


state 56

    (88) llamada -> ID LPAREN . auxLlamada RPAREN SEMICOLON
    (89) auxLlamada -> . argumentos
    (90) auxLlamada -> .
    (91) argumentos -> . auxArgumentos1
    (92) argumentos -> .
    (93) auxArgumentos1 -> . exp ambAuxArgumentos1
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

  ! reduce/reduce conflict for RPAREN resolved using rule 90 (auxLlamada -> .)
    RPAREN          reduce using rule 90 (auxLlamada -> .)
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

  ! RPAREN          [ reduce using rule 92 (argumentos -> .) ]

    auxLlamada                     shift and go to state 82
    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 81
    factor                         shift and go to state 70
    argumentos                     shift and go to state 83
    auxFactor                      shift and go to state 66
    auxArgumentos1                 shift and go to state 84
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 57

    (17) auxTipo1 -> auxTipo2 LBRACKET CTEINT RBRACKET .

    FUNCTION        reduce using rule 17 (auxTipo1 -> auxTipo2 LBRACKET CTEINT RBRACKET .)
    ID              reduce using rule 17 (auxTipo1 -> auxTipo2 LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 17 (auxTipo1 -> auxTipo2 LBRACKET CTEINT RBRACKET .)


state 58

    (8) auxVar1 -> idVars COLON addTypeGlobal . tipo SEMICOLON auxVar1
    (15) tipo -> . auxTipo1
    (16) tipo -> . CHAR
    (17) auxTipo1 -> . auxTipo2 LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> . auxTipo2
    (19) auxTipo2 -> . INT
    (20) auxTipo2 -> . BOOL
    (21) auxTipo2 -> . STRING
    (22) auxTipo2 -> . FLOAT

    CHAR            shift and go to state 11
    INT             shift and go to state 16
    BOOL            shift and go to state 13
    STRING          shift and go to state 15
    FLOAT           shift and go to state 17

    tipo                           shift and go to state 85
    auxTipo1                       shift and go to state 19
    auxTipo2                       shift and go to state 20

state 59

    (11) idVars -> addVariableDir ID ambIdVars .

    COLON           reduce using rule 11 (idVars -> addVariableDir ID ambIdVars .)


state 60

    (13) ambIdVars -> COMMA . idVars
    (11) idVars -> . addVariableDir ID ambIdVars
    (12) addVariableDir -> .

    ID              reduce using rule 12 (addVariableDir -> .)

    idVars                         shift and go to state 86
    addVariableDir                 shift and go to state 28

state 61

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN . auxFunction RPAREN bloque
    (81) auxFunction -> . parametros
    (82) auxFunction -> .
    (83) parametros -> . auxParametros
    (84) auxParametros -> . tipo ID ambAuxParametros
    (15) tipo -> . auxTipo1
    (16) tipo -> . CHAR
    (17) auxTipo1 -> . auxTipo2 LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> . auxTipo2
    (19) auxTipo2 -> . INT
    (20) auxTipo2 -> . BOOL
    (21) auxTipo2 -> . STRING
    (22) auxTipo2 -> . FLOAT

    RPAREN          reduce using rule 82 (auxFunction -> .)
    CHAR            shift and go to state 11
    INT             shift and go to state 16
    BOOL            shift and go to state 13
    STRING          shift and go to state 15
    FLOAT           shift and go to state 17

    tipo                           shift and go to state 87
    auxFunction                    shift and go to state 88
    auxParametros                  shift and go to state 89
    auxTipo2                       shift and go to state 20
    auxTipo1                       shift and go to state 19
    parametros                     shift and go to state 90

state 62

    (96) lectura -> READ LPAREN ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 91


state 63

    (87) ciclo -> WHILE LPAREN expresion . RPAREN bloque SEMICOLON

    RPAREN          shift and go to state 92


state 64

    (41) expresion -> exp . auxExpresion exp
    (43) auxExpresion -> . GTHAN
    (44) auxExpresion -> . LTHAN
    (45) auxExpresion -> . NOTEQUAL
    (46) auxExpresion -> . GETHAN
    (47) auxExpresion -> . LETHAN
    (48) auxExpresion -> . EQUAL

    GTHAN           shift and go to state 95
    LTHAN           shift and go to state 98
    NOTEQUAL        shift and go to state 93
    GETHAN          shift and go to state 97
    LETHAN          shift and go to state 99
    EQUAL           shift and go to state 96

    auxExpresion                   shift and go to state 94

state 65

    (66) auxFactor -> auxExp .

    ID              reduce using rule 66 (auxFactor -> auxExp .)
    CTEINT          reduce using rule 66 (auxFactor -> auxExp .)
    CTEFLOAT        reduce using rule 66 (auxFactor -> auxExp .)
    CTECHAR         reduce using rule 66 (auxFactor -> auxExp .)
    CTEBOOL         reduce using rule 66 (auxFactor -> auxExp .)
    CTESTRING       reduce using rule 66 (auxFactor -> auxExp .)


state 66

    (65) factor -> auxFactor . varcte
    (68) varcte -> . ID auxVarcte
    (69) varcte -> . CTEINT
    (70) varcte -> . CTEFLOAT
    (71) varcte -> . CTECHAR
    (72) varcte -> . CTEBOOL
    (73) varcte -> . CTESTRING

    ID              shift and go to state 106
    CTEINT          shift and go to state 103
    CTEFLOAT        shift and go to state 104
    CTECHAR         shift and go to state 105
    CTEBOOL         shift and go to state 102
    CTESTRING       shift and go to state 100

    varcte                         shift and go to state 101

state 67

    (56) auxExp -> PLUS .

    ID              reduce using rule 56 (auxExp -> PLUS .)
    CTEINT          reduce using rule 56 (auxExp -> PLUS .)
    CTEFLOAT        reduce using rule 56 (auxExp -> PLUS .)
    CTECHAR         reduce using rule 56 (auxExp -> PLUS .)
    CTEBOOL         reduce using rule 56 (auxExp -> PLUS .)
    CTESTRING       reduce using rule 56 (auxExp -> PLUS .)
    LPAREN          reduce using rule 56 (auxExp -> PLUS .)
    PLUS            reduce using rule 56 (auxExp -> PLUS .)
    MINUS           reduce using rule 56 (auxExp -> PLUS .)


state 68

    (53) cicloExp -> termino . ambExp
    (54) ambExp -> . auxExp cicloExp
    (55) ambExp -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    GTHAN           reduce using rule 55 (ambExp -> .)
    LTHAN           reduce using rule 55 (ambExp -> .)
    NOTEQUAL        reduce using rule 55 (ambExp -> .)
    GETHAN          reduce using rule 55 (ambExp -> .)
    LETHAN          reduce using rule 55 (ambExp -> .)
    EQUAL           reduce using rule 55 (ambExp -> .)
    COMMA           reduce using rule 55 (ambExp -> .)
    RPAREN          reduce using rule 55 (ambExp -> .)
    RBRACKET        reduce using rule 55 (ambExp -> .)
    SEMICOLON       reduce using rule 55 (ambExp -> .)
    LBRACKET        reduce using rule 55 (ambExp -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    ambExp                         shift and go to state 108
    auxExp                         shift and go to state 107

state 69

    (64) factor -> LPAREN . expresion RPAREN
    (41) expresion -> . exp auxExpresion exp
    (42) expresion -> .
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    RPAREN          reduce using rule 42 (expresion -> .)
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    expresion                      shift and go to state 109
    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 64
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 70

    (59) cicloTermino -> factor . ambCicloTermino
    (60) ambCicloTermino -> . auxTermino cicloTermino
    (61) ambCicloTermino -> .
    (62) auxTermino -> . MULTI
    (63) auxTermino -> . DIVIDE

    PLUS            reduce using rule 61 (ambCicloTermino -> .)
    MINUS           reduce using rule 61 (ambCicloTermino -> .)
    GTHAN           reduce using rule 61 (ambCicloTermino -> .)
    LTHAN           reduce using rule 61 (ambCicloTermino -> .)
    NOTEQUAL        reduce using rule 61 (ambCicloTermino -> .)
    GETHAN          reduce using rule 61 (ambCicloTermino -> .)
    LETHAN          reduce using rule 61 (ambCicloTermino -> .)
    EQUAL           reduce using rule 61 (ambCicloTermino -> .)
    COMMA           reduce using rule 61 (ambCicloTermino -> .)
    RPAREN          reduce using rule 61 (ambCicloTermino -> .)
    RBRACKET        reduce using rule 61 (ambCicloTermino -> .)
    SEMICOLON       reduce using rule 61 (ambCicloTermino -> .)
    LBRACKET        reduce using rule 61 (ambCicloTermino -> .)
    MULTI           shift and go to state 110
    DIVIDE          shift and go to state 111

    ambCicloTermino                shift and go to state 113
    auxTermino                     shift and go to state 112

state 71

    (57) auxExp -> MINUS .

    ID              reduce using rule 57 (auxExp -> MINUS .)
    CTEINT          reduce using rule 57 (auxExp -> MINUS .)
    CTEFLOAT        reduce using rule 57 (auxExp -> MINUS .)
    CTECHAR         reduce using rule 57 (auxExp -> MINUS .)
    CTEBOOL         reduce using rule 57 (auxExp -> MINUS .)
    CTESTRING       reduce using rule 57 (auxExp -> MINUS .)
    LPAREN          reduce using rule 57 (auxExp -> MINUS .)
    PLUS            reduce using rule 57 (auxExp -> MINUS .)
    MINUS           reduce using rule 57 (auxExp -> MINUS .)


state 72

    (52) exp -> cicloExp .

    COMMA           reduce using rule 52 (exp -> cicloExp .)
    RPAREN          reduce using rule 52 (exp -> cicloExp .)
    GTHAN           reduce using rule 52 (exp -> cicloExp .)
    LTHAN           reduce using rule 52 (exp -> cicloExp .)
    NOTEQUAL        reduce using rule 52 (exp -> cicloExp .)
    GETHAN          reduce using rule 52 (exp -> cicloExp .)
    LETHAN          reduce using rule 52 (exp -> cicloExp .)
    EQUAL           reduce using rule 52 (exp -> cicloExp .)
    SEMICOLON       reduce using rule 52 (exp -> cicloExp .)
    LBRACKET        reduce using rule 52 (exp -> cicloExp .)
    RBRACKET        reduce using rule 52 (exp -> cicloExp .)


state 73

    (58) termino -> cicloTermino .

    PLUS            reduce using rule 58 (termino -> cicloTermino .)
    MINUS           reduce using rule 58 (termino -> cicloTermino .)
    RPAREN          reduce using rule 58 (termino -> cicloTermino .)
    GTHAN           reduce using rule 58 (termino -> cicloTermino .)
    LTHAN           reduce using rule 58 (termino -> cicloTermino .)
    NOTEQUAL        reduce using rule 58 (termino -> cicloTermino .)
    GETHAN          reduce using rule 58 (termino -> cicloTermino .)
    LETHAN          reduce using rule 58 (termino -> cicloTermino .)
    EQUAL           reduce using rule 58 (termino -> cicloTermino .)
    COMMA           reduce using rule 58 (termino -> cicloTermino .)
    RBRACKET        reduce using rule 58 (termino -> cicloTermino .)
    SEMICOLON       reduce using rule 58 (termino -> cicloTermino .)
    LBRACKET        reduce using rule 58 (termino -> cicloTermino .)


state 74

    (39) auxEscritura2 -> exp .

    COMMA           reduce using rule 39 (auxEscritura2 -> exp .)
    RPAREN          reduce using rule 39 (auxEscritura2 -> exp .)


state 75

    (35) escritura -> PRINT LPAREN auxEscritura1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 114


state 76

    (36) auxEscritura1 -> auxEscritura2 . ambAuxEscritura1
    (37) ambAuxEscritura1 -> . COMMA auxEscritura1
    (38) ambAuxEscritura1 -> .

    COMMA           shift and go to state 115
    RPAREN          reduce using rule 38 (ambAuxEscritura1 -> .)

    ambAuxEscritura1               shift and go to state 116

state 77

    (40) auxEscritura2 -> CTESTRING .

    COMMA           reduce using rule 40 (auxEscritura2 -> CTESTRING .)
    RPAREN          reduce using rule 40 (auxEscritura2 -> CTESTRING .)


state 78

    (49) condicion -> IF LPAREN expresion . RPAREN bloque auxCondicion SEMICOLON

    RPAREN          shift and go to state 117


state 79

    (33) auxAsignacion1 -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 118


state 80

    (32) asignacion -> ID auxAsignacion1 EQUALA . exp SEMICOLON
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 119
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 81

    (93) auxArgumentos1 -> exp . ambAuxArgumentos1
    (94) ambAuxArgumentos1 -> . COMMA auxArgumentos1
    (95) ambAuxArgumentos1 -> .

    COMMA           shift and go to state 121
    RPAREN          reduce using rule 95 (ambAuxArgumentos1 -> .)

    ambAuxArgumentos1              shift and go to state 120

state 82

    (88) llamada -> ID LPAREN auxLlamada . RPAREN SEMICOLON

    RPAREN          shift and go to state 122


state 83

    (89) auxLlamada -> argumentos .

    RPAREN          reduce using rule 89 (auxLlamada -> argumentos .)


state 84

    (91) argumentos -> auxArgumentos1 .

    RPAREN          reduce using rule 91 (argumentos -> auxArgumentos1 .)


state 85

    (8) auxVar1 -> idVars COLON addTypeGlobal tipo . SEMICOLON auxVar1

    SEMICOLON       shift and go to state 123


state 86

    (13) ambIdVars -> COMMA idVars .

    COLON           reduce using rule 13 (ambIdVars -> COMMA idVars .)


state 87

    (84) auxParametros -> tipo . ID ambAuxParametros

    ID              shift and go to state 124


state 88

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction . RPAREN bloque

    RPAREN          shift and go to state 125


state 89

    (83) parametros -> auxParametros .

    RPAREN          reduce using rule 83 (parametros -> auxParametros .)


state 90

    (81) auxFunction -> parametros .

    RPAREN          reduce using rule 81 (auxFunction -> parametros .)


state 91

    (96) lectura -> READ LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 126


state 92

    (87) ciclo -> WHILE LPAREN expresion RPAREN . bloque SEMICOLON
    (23) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 25

    bloque                         shift and go to state 127

state 93

    (45) auxExpresion -> NOTEQUAL .

    LPAREN          reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    PLUS            reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    MINUS           reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    ID              reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    CTEINT          reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    CTEFLOAT        reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    CTECHAR         reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    CTEBOOL         reduce using rule 45 (auxExpresion -> NOTEQUAL .)
    CTESTRING       reduce using rule 45 (auxExpresion -> NOTEQUAL .)


state 94

    (41) expresion -> exp auxExpresion . exp
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 128
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 95

    (43) auxExpresion -> GTHAN .

    LPAREN          reduce using rule 43 (auxExpresion -> GTHAN .)
    PLUS            reduce using rule 43 (auxExpresion -> GTHAN .)
    MINUS           reduce using rule 43 (auxExpresion -> GTHAN .)
    ID              reduce using rule 43 (auxExpresion -> GTHAN .)
    CTEINT          reduce using rule 43 (auxExpresion -> GTHAN .)
    CTEFLOAT        reduce using rule 43 (auxExpresion -> GTHAN .)
    CTECHAR         reduce using rule 43 (auxExpresion -> GTHAN .)
    CTEBOOL         reduce using rule 43 (auxExpresion -> GTHAN .)
    CTESTRING       reduce using rule 43 (auxExpresion -> GTHAN .)


state 96

    (48) auxExpresion -> EQUAL .

    LPAREN          reduce using rule 48 (auxExpresion -> EQUAL .)
    PLUS            reduce using rule 48 (auxExpresion -> EQUAL .)
    MINUS           reduce using rule 48 (auxExpresion -> EQUAL .)
    ID              reduce using rule 48 (auxExpresion -> EQUAL .)
    CTEINT          reduce using rule 48 (auxExpresion -> EQUAL .)
    CTEFLOAT        reduce using rule 48 (auxExpresion -> EQUAL .)
    CTECHAR         reduce using rule 48 (auxExpresion -> EQUAL .)
    CTEBOOL         reduce using rule 48 (auxExpresion -> EQUAL .)
    CTESTRING       reduce using rule 48 (auxExpresion -> EQUAL .)


state 97

    (46) auxExpresion -> GETHAN .

    LPAREN          reduce using rule 46 (auxExpresion -> GETHAN .)
    PLUS            reduce using rule 46 (auxExpresion -> GETHAN .)
    MINUS           reduce using rule 46 (auxExpresion -> GETHAN .)
    ID              reduce using rule 46 (auxExpresion -> GETHAN .)
    CTEINT          reduce using rule 46 (auxExpresion -> GETHAN .)
    CTEFLOAT        reduce using rule 46 (auxExpresion -> GETHAN .)
    CTECHAR         reduce using rule 46 (auxExpresion -> GETHAN .)
    CTEBOOL         reduce using rule 46 (auxExpresion -> GETHAN .)
    CTESTRING       reduce using rule 46 (auxExpresion -> GETHAN .)


state 98

    (44) auxExpresion -> LTHAN .

    LPAREN          reduce using rule 44 (auxExpresion -> LTHAN .)
    PLUS            reduce using rule 44 (auxExpresion -> LTHAN .)
    MINUS           reduce using rule 44 (auxExpresion -> LTHAN .)
    ID              reduce using rule 44 (auxExpresion -> LTHAN .)
    CTEINT          reduce using rule 44 (auxExpresion -> LTHAN .)
    CTEFLOAT        reduce using rule 44 (auxExpresion -> LTHAN .)
    CTECHAR         reduce using rule 44 (auxExpresion -> LTHAN .)
    CTEBOOL         reduce using rule 44 (auxExpresion -> LTHAN .)
    CTESTRING       reduce using rule 44 (auxExpresion -> LTHAN .)


state 99

    (47) auxExpresion -> LETHAN .

    LPAREN          reduce using rule 47 (auxExpresion -> LETHAN .)
    PLUS            reduce using rule 47 (auxExpresion -> LETHAN .)
    MINUS           reduce using rule 47 (auxExpresion -> LETHAN .)
    ID              reduce using rule 47 (auxExpresion -> LETHAN .)
    CTEINT          reduce using rule 47 (auxExpresion -> LETHAN .)
    CTEFLOAT        reduce using rule 47 (auxExpresion -> LETHAN .)
    CTECHAR         reduce using rule 47 (auxExpresion -> LETHAN .)
    CTEBOOL         reduce using rule 47 (auxExpresion -> LETHAN .)
    CTESTRING       reduce using rule 47 (auxExpresion -> LETHAN .)


state 100

    (73) varcte -> CTESTRING .

    MULTI           reduce using rule 73 (varcte -> CTESTRING .)
    DIVIDE          reduce using rule 73 (varcte -> CTESTRING .)
    PLUS            reduce using rule 73 (varcte -> CTESTRING .)
    MINUS           reduce using rule 73 (varcte -> CTESTRING .)
    GTHAN           reduce using rule 73 (varcte -> CTESTRING .)
    LTHAN           reduce using rule 73 (varcte -> CTESTRING .)
    NOTEQUAL        reduce using rule 73 (varcte -> CTESTRING .)
    GETHAN          reduce using rule 73 (varcte -> CTESTRING .)
    LETHAN          reduce using rule 73 (varcte -> CTESTRING .)
    EQUAL           reduce using rule 73 (varcte -> CTESTRING .)
    COMMA           reduce using rule 73 (varcte -> CTESTRING .)
    RPAREN          reduce using rule 73 (varcte -> CTESTRING .)
    RBRACKET        reduce using rule 73 (varcte -> CTESTRING .)
    SEMICOLON       reduce using rule 73 (varcte -> CTESTRING .)
    LBRACKET        reduce using rule 73 (varcte -> CTESTRING .)


state 101

    (65) factor -> auxFactor varcte .

    MULTI           reduce using rule 65 (factor -> auxFactor varcte .)
    DIVIDE          reduce using rule 65 (factor -> auxFactor varcte .)
    PLUS            reduce using rule 65 (factor -> auxFactor varcte .)
    MINUS           reduce using rule 65 (factor -> auxFactor varcte .)
    RBRACKET        reduce using rule 65 (factor -> auxFactor varcte .)
    COMMA           reduce using rule 65 (factor -> auxFactor varcte .)
    RPAREN          reduce using rule 65 (factor -> auxFactor varcte .)
    GTHAN           reduce using rule 65 (factor -> auxFactor varcte .)
    LTHAN           reduce using rule 65 (factor -> auxFactor varcte .)
    NOTEQUAL        reduce using rule 65 (factor -> auxFactor varcte .)
    GETHAN          reduce using rule 65 (factor -> auxFactor varcte .)
    LETHAN          reduce using rule 65 (factor -> auxFactor varcte .)
    EQUAL           reduce using rule 65 (factor -> auxFactor varcte .)
    SEMICOLON       reduce using rule 65 (factor -> auxFactor varcte .)
    LBRACKET        reduce using rule 65 (factor -> auxFactor varcte .)


state 102

    (72) varcte -> CTEBOOL .

    MULTI           reduce using rule 72 (varcte -> CTEBOOL .)
    DIVIDE          reduce using rule 72 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 72 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 72 (varcte -> CTEBOOL .)
    GTHAN           reduce using rule 72 (varcte -> CTEBOOL .)
    LTHAN           reduce using rule 72 (varcte -> CTEBOOL .)
    NOTEQUAL        reduce using rule 72 (varcte -> CTEBOOL .)
    GETHAN          reduce using rule 72 (varcte -> CTEBOOL .)
    LETHAN          reduce using rule 72 (varcte -> CTEBOOL .)
    EQUAL           reduce using rule 72 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 72 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 72 (varcte -> CTEBOOL .)
    RBRACKET        reduce using rule 72 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 72 (varcte -> CTEBOOL .)
    LBRACKET        reduce using rule 72 (varcte -> CTEBOOL .)


state 103

    (69) varcte -> CTEINT .

    MULTI           reduce using rule 69 (varcte -> CTEINT .)
    DIVIDE          reduce using rule 69 (varcte -> CTEINT .)
    PLUS            reduce using rule 69 (varcte -> CTEINT .)
    MINUS           reduce using rule 69 (varcte -> CTEINT .)
    GTHAN           reduce using rule 69 (varcte -> CTEINT .)
    LTHAN           reduce using rule 69 (varcte -> CTEINT .)
    NOTEQUAL        reduce using rule 69 (varcte -> CTEINT .)
    GETHAN          reduce using rule 69 (varcte -> CTEINT .)
    LETHAN          reduce using rule 69 (varcte -> CTEINT .)
    EQUAL           reduce using rule 69 (varcte -> CTEINT .)
    COMMA           reduce using rule 69 (varcte -> CTEINT .)
    RPAREN          reduce using rule 69 (varcte -> CTEINT .)
    RBRACKET        reduce using rule 69 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 69 (varcte -> CTEINT .)
    LBRACKET        reduce using rule 69 (varcte -> CTEINT .)


state 104

    (70) varcte -> CTEFLOAT .

    MULTI           reduce using rule 70 (varcte -> CTEFLOAT .)
    DIVIDE          reduce using rule 70 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 70 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 70 (varcte -> CTEFLOAT .)
    GTHAN           reduce using rule 70 (varcte -> CTEFLOAT .)
    LTHAN           reduce using rule 70 (varcte -> CTEFLOAT .)
    NOTEQUAL        reduce using rule 70 (varcte -> CTEFLOAT .)
    GETHAN          reduce using rule 70 (varcte -> CTEFLOAT .)
    LETHAN          reduce using rule 70 (varcte -> CTEFLOAT .)
    EQUAL           reduce using rule 70 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 70 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 70 (varcte -> CTEFLOAT .)
    RBRACKET        reduce using rule 70 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 70 (varcte -> CTEFLOAT .)
    LBRACKET        reduce using rule 70 (varcte -> CTEFLOAT .)


state 105

    (71) varcte -> CTECHAR .

    MULTI           reduce using rule 71 (varcte -> CTECHAR .)
    DIVIDE          reduce using rule 71 (varcte -> CTECHAR .)
    PLUS            reduce using rule 71 (varcte -> CTECHAR .)
    MINUS           reduce using rule 71 (varcte -> CTECHAR .)
    GTHAN           reduce using rule 71 (varcte -> CTECHAR .)
    LTHAN           reduce using rule 71 (varcte -> CTECHAR .)
    NOTEQUAL        reduce using rule 71 (varcte -> CTECHAR .)
    GETHAN          reduce using rule 71 (varcte -> CTECHAR .)
    LETHAN          reduce using rule 71 (varcte -> CTECHAR .)
    EQUAL           reduce using rule 71 (varcte -> CTECHAR .)
    COMMA           reduce using rule 71 (varcte -> CTECHAR .)
    RPAREN          reduce using rule 71 (varcte -> CTECHAR .)
    RBRACKET        reduce using rule 71 (varcte -> CTECHAR .)
    SEMICOLON       reduce using rule 71 (varcte -> CTECHAR .)
    LBRACKET        reduce using rule 71 (varcte -> CTECHAR .)


state 106

    (68) varcte -> ID . auxVarcte
    (74) auxVarcte -> . LPAREN exp RPAREN
    (75) auxVarcte -> . LBRACKET exp LBRACKET
    (76) auxVarcte -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 129
    LBRACKET        shift and go to state 130
    MULTI           reduce using rule 76 (auxVarcte -> .)
    DIVIDE          reduce using rule 76 (auxVarcte -> .)
    PLUS            reduce using rule 76 (auxVarcte -> .)
    MINUS           reduce using rule 76 (auxVarcte -> .)
    GTHAN           reduce using rule 76 (auxVarcte -> .)
    LTHAN           reduce using rule 76 (auxVarcte -> .)
    NOTEQUAL        reduce using rule 76 (auxVarcte -> .)
    GETHAN          reduce using rule 76 (auxVarcte -> .)
    LETHAN          reduce using rule 76 (auxVarcte -> .)
    EQUAL           reduce using rule 76 (auxVarcte -> .)
    COMMA           reduce using rule 76 (auxVarcte -> .)
    RPAREN          reduce using rule 76 (auxVarcte -> .)
    RBRACKET        reduce using rule 76 (auxVarcte -> .)
    SEMICOLON       reduce using rule 76 (auxVarcte -> .)

  ! LBRACKET        [ reduce using rule 76 (auxVarcte -> .) ]

    auxVarcte                      shift and go to state 131

state 107

    (54) ambExp -> auxExp . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    cicloExp                       shift and go to state 132
    termino                        shift and go to state 68
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    auxExp                         shift and go to state 65
    cicloTermino                   shift and go to state 73

state 108

    (53) cicloExp -> termino ambExp .

    RPAREN          reduce using rule 53 (cicloExp -> termino ambExp .)
    GTHAN           reduce using rule 53 (cicloExp -> termino ambExp .)
    LTHAN           reduce using rule 53 (cicloExp -> termino ambExp .)
    NOTEQUAL        reduce using rule 53 (cicloExp -> termino ambExp .)
    GETHAN          reduce using rule 53 (cicloExp -> termino ambExp .)
    LETHAN          reduce using rule 53 (cicloExp -> termino ambExp .)
    EQUAL           reduce using rule 53 (cicloExp -> termino ambExp .)
    COMMA           reduce using rule 53 (cicloExp -> termino ambExp .)
    LBRACKET        reduce using rule 53 (cicloExp -> termino ambExp .)
    RBRACKET        reduce using rule 53 (cicloExp -> termino ambExp .)
    SEMICOLON       reduce using rule 53 (cicloExp -> termino ambExp .)


state 109

    (64) factor -> LPAREN expresion . RPAREN

    RPAREN          shift and go to state 133


state 110

    (62) auxTermino -> MULTI .

    LPAREN          reduce using rule 62 (auxTermino -> MULTI .)
    PLUS            reduce using rule 62 (auxTermino -> MULTI .)
    MINUS           reduce using rule 62 (auxTermino -> MULTI .)
    ID              reduce using rule 62 (auxTermino -> MULTI .)
    CTEINT          reduce using rule 62 (auxTermino -> MULTI .)
    CTEFLOAT        reduce using rule 62 (auxTermino -> MULTI .)
    CTECHAR         reduce using rule 62 (auxTermino -> MULTI .)
    CTEBOOL         reduce using rule 62 (auxTermino -> MULTI .)
    CTESTRING       reduce using rule 62 (auxTermino -> MULTI .)


state 111

    (63) auxTermino -> DIVIDE .

    LPAREN          reduce using rule 63 (auxTermino -> DIVIDE .)
    PLUS            reduce using rule 63 (auxTermino -> DIVIDE .)
    MINUS           reduce using rule 63 (auxTermino -> DIVIDE .)
    ID              reduce using rule 63 (auxTermino -> DIVIDE .)
    CTEINT          reduce using rule 63 (auxTermino -> DIVIDE .)
    CTEFLOAT        reduce using rule 63 (auxTermino -> DIVIDE .)
    CTECHAR         reduce using rule 63 (auxTermino -> DIVIDE .)
    CTEBOOL         reduce using rule 63 (auxTermino -> DIVIDE .)
    CTESTRING       reduce using rule 63 (auxTermino -> DIVIDE .)


state 112

    (60) ambCicloTermino -> auxTermino . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    auxExp                         shift and go to state 65
    cicloTermino                   shift and go to state 134

state 113

    (59) cicloTermino -> factor ambCicloTermino .

    PLUS            reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    MINUS           reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    GTHAN           reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    LTHAN           reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    NOTEQUAL        reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    GETHAN          reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    LETHAN          reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    EQUAL           reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    COMMA           reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    RPAREN          reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    SEMICOLON       reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    RBRACKET        reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)
    LBRACKET        reduce using rule 59 (cicloTermino -> factor ambCicloTermino .)


state 114

    (35) escritura -> PRINT LPAREN auxEscritura1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 115

    (37) ambAuxEscritura1 -> COMMA . auxEscritura1
    (36) auxEscritura1 -> . auxEscritura2 ambAuxEscritura1
    (39) auxEscritura2 -> . exp
    (40) auxEscritura2 -> . CTESTRING
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

  ! shift/reduce conflict for CTESTRING resolved as shift
    CTESTRING       shift and go to state 77
    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

  ! CTESTRING       [ reduce using rule 67 (auxFactor -> .) ]

    auxEscritura1                  shift and go to state 136
    auxEscritura2                  shift and go to state 76
    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 74
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 116

    (36) auxEscritura1 -> auxEscritura2 ambAuxEscritura1 .

    RPAREN          reduce using rule 36 (auxEscritura1 -> auxEscritura2 ambAuxEscritura1 .)


state 117

    (49) condicion -> IF LPAREN expresion RPAREN . bloque auxCondicion SEMICOLON
    (23) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 25

    bloque                         shift and go to state 137

state 118

    (33) auxAsignacion1 -> LBRACKET exp RBRACKET .

    EQUALA          reduce using rule 33 (auxAsignacion1 -> LBRACKET exp RBRACKET .)


state 119

    (32) asignacion -> ID auxAsignacion1 EQUALA exp . SEMICOLON

    SEMICOLON       shift and go to state 138


state 120

    (93) auxArgumentos1 -> exp ambAuxArgumentos1 .

    RPAREN          reduce using rule 93 (auxArgumentos1 -> exp ambAuxArgumentos1 .)


state 121

    (94) ambAuxArgumentos1 -> COMMA . auxArgumentos1
    (93) auxArgumentos1 -> . exp ambAuxArgumentos1
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 81
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    auxArgumentos1                 shift and go to state 139
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 122

    (88) llamada -> ID LPAREN auxLlamada RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 140


state 123

    (8) auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON . auxVar1
    (8) auxVar1 -> . idVars COLON addTypeGlobal tipo SEMICOLON auxVar1
    (9) auxVar1 -> .
    (11) idVars -> . addVariableDir ID ambIdVars
    (12) addVariableDir -> .

    VAR             reduce using rule 9 (auxVar1 -> .)
    CHAR            reduce using rule 9 (auxVar1 -> .)
    INT             reduce using rule 9 (auxVar1 -> .)
    BOOL            reduce using rule 9 (auxVar1 -> .)
    STRING          reduce using rule 9 (auxVar1 -> .)
    FLOAT           reduce using rule 9 (auxVar1 -> .)
    LBRACE          reduce using rule 9 (auxVar1 -> .)
    ID              reduce using rule 12 (addVariableDir -> .)

    idVars                         shift and go to state 27
    addVariableDir                 shift and go to state 28
    auxVar1                        shift and go to state 141

state 124

    (84) auxParametros -> tipo ID . ambAuxParametros
    (85) ambAuxParametros -> . COMMA auxParametros
    (86) ambAuxParametros -> .

    COMMA           shift and go to state 143
    RPAREN          reduce using rule 86 (ambAuxParametros -> .)

    ambAuxParametros               shift and go to state 142

state 125

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN . bloque
    (23) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 25

    bloque                         shift and go to state 144

state 126

    (96) lectura -> READ LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    PRINT           reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    READ            reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 96 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)


state 127

    (87) ciclo -> WHILE LPAREN expresion RPAREN bloque . SEMICOLON

    SEMICOLON       shift and go to state 145


state 128

    (41) expresion -> exp auxExpresion exp .

    RPAREN          reduce using rule 41 (expresion -> exp auxExpresion exp .)


state 129

    (74) auxVarcte -> LPAREN . exp RPAREN
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 146
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 130

    (75) auxVarcte -> LBRACKET . exp LBRACKET
    (52) exp -> . cicloExp
    (53) cicloExp -> . termino ambExp
    (58) termino -> . cicloTermino
    (59) cicloTermino -> . factor ambCicloTermino
    (64) factor -> . LPAREN expresion RPAREN
    (65) factor -> . auxFactor varcte
    (66) auxFactor -> . auxExp
    (67) auxFactor -> .
    (56) auxExp -> . PLUS
    (57) auxExp -> . MINUS

    LPAREN          shift and go to state 69
    ID              reduce using rule 67 (auxFactor -> .)
    CTEINT          reduce using rule 67 (auxFactor -> .)
    CTEFLOAT        reduce using rule 67 (auxFactor -> .)
    CTECHAR         reduce using rule 67 (auxFactor -> .)
    CTEBOOL         reduce using rule 67 (auxFactor -> .)
    CTESTRING       reduce using rule 67 (auxFactor -> .)
    PLUS            shift and go to state 67
    MINUS           shift and go to state 71

    auxExp                         shift and go to state 65
    termino                        shift and go to state 68
    exp                            shift and go to state 147
    factor                         shift and go to state 70
    auxFactor                      shift and go to state 66
    cicloExp                       shift and go to state 72
    cicloTermino                   shift and go to state 73

state 131

    (68) varcte -> ID auxVarcte .

    MULTI           reduce using rule 68 (varcte -> ID auxVarcte .)
    DIVIDE          reduce using rule 68 (varcte -> ID auxVarcte .)
    PLUS            reduce using rule 68 (varcte -> ID auxVarcte .)
    MINUS           reduce using rule 68 (varcte -> ID auxVarcte .)
    GTHAN           reduce using rule 68 (varcte -> ID auxVarcte .)
    LTHAN           reduce using rule 68 (varcte -> ID auxVarcte .)
    NOTEQUAL        reduce using rule 68 (varcte -> ID auxVarcte .)
    GETHAN          reduce using rule 68 (varcte -> ID auxVarcte .)
    LETHAN          reduce using rule 68 (varcte -> ID auxVarcte .)
    EQUAL           reduce using rule 68 (varcte -> ID auxVarcte .)
    COMMA           reduce using rule 68 (varcte -> ID auxVarcte .)
    RPAREN          reduce using rule 68 (varcte -> ID auxVarcte .)
    RBRACKET        reduce using rule 68 (varcte -> ID auxVarcte .)
    SEMICOLON       reduce using rule 68 (varcte -> ID auxVarcte .)
    LBRACKET        reduce using rule 68 (varcte -> ID auxVarcte .)


state 132

    (54) ambExp -> auxExp cicloExp .

    GTHAN           reduce using rule 54 (ambExp -> auxExp cicloExp .)
    LTHAN           reduce using rule 54 (ambExp -> auxExp cicloExp .)
    NOTEQUAL        reduce using rule 54 (ambExp -> auxExp cicloExp .)
    GETHAN          reduce using rule 54 (ambExp -> auxExp cicloExp .)
    LETHAN          reduce using rule 54 (ambExp -> auxExp cicloExp .)
    EQUAL           reduce using rule 54 (ambExp -> auxExp cicloExp .)
    COMMA           reduce using rule 54 (ambExp -> auxExp cicloExp .)
    RPAREN          reduce using rule 54 (ambExp -> auxExp cicloExp .)
    RBRACKET        reduce using rule 54 (ambExp -> auxExp cicloExp .)
    SEMICOLON       reduce using rule 54 (ambExp -> auxExp cicloExp .)
    LBRACKET        reduce using rule 54 (ambExp -> auxExp cicloExp .)


state 133

    (64) factor -> LPAREN expresion RPAREN .

    MULTI           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    DIVIDE          reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    PLUS            reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    MINUS           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    RBRACKET        reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    COMMA           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    RPAREN          reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    GTHAN           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    LTHAN           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    NOTEQUAL        reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    GETHAN          reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    LETHAN          reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    EQUAL           reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    SEMICOLON       reduce using rule 64 (factor -> LPAREN expresion RPAREN .)
    LBRACKET        reduce using rule 64 (factor -> LPAREN expresion RPAREN .)


state 134

    (60) ambCicloTermino -> auxTermino cicloTermino .

    PLUS            reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    MINUS           reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    GTHAN           reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    LTHAN           reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    NOTEQUAL        reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    GETHAN          reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    LETHAN          reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    EQUAL           reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    COMMA           reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    RPAREN          reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    RBRACKET        reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    SEMICOLON       reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)
    LBRACKET        reduce using rule 60 (ambCicloTermino -> auxTermino cicloTermino .)


state 135

    (35) escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .

    ID              reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    IF              reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    READ            reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    RBRACE          reduce using rule 35 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)


state 136

    (37) ambAuxEscritura1 -> COMMA auxEscritura1 .

    RPAREN          reduce using rule 37 (ambAuxEscritura1 -> COMMA auxEscritura1 .)


state 137

    (49) condicion -> IF LPAREN expresion RPAREN bloque . auxCondicion SEMICOLON
    (50) auxCondicion -> . ELSE bloque
    (51) auxCondicion -> .

    ELSE            shift and go to state 148
    SEMICOLON       reduce using rule 51 (auxCondicion -> .)

    auxCondicion                   shift and go to state 149

state 138

    (32) asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .

    ID              reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    IF              reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    PRINT           reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    READ            reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    WHILE           reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    RBRACE          reduce using rule 32 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)


state 139

    (94) ambAuxArgumentos1 -> COMMA auxArgumentos1 .

    RPAREN          reduce using rule 94 (ambAuxArgumentos1 -> COMMA auxArgumentos1 .)


state 140

    (88) llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .

    ID              reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    IF              reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    PRINT           reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    READ            reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    WHILE           reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    RBRACE          reduce using rule 88 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)


state 141

    (8) auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .

    VAR             reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    CHAR            reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    INT             reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    BOOL            reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    STRING          reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    FLOAT           reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)
    LBRACE          reduce using rule 8 (auxVar1 -> idVars COLON addTypeGlobal tipo SEMICOLON auxVar1 .)


state 142

    (84) auxParametros -> tipo ID ambAuxParametros .

    RPAREN          reduce using rule 84 (auxParametros -> tipo ID ambAuxParametros .)


state 143

    (85) ambAuxParametros -> COMMA . auxParametros
    (84) auxParametros -> . tipo ID ambAuxParametros
    (15) tipo -> . auxTipo1
    (16) tipo -> . CHAR
    (17) auxTipo1 -> . auxTipo2 LBRACKET CTEINT RBRACKET
    (18) auxTipo1 -> . auxTipo2
    (19) auxTipo2 -> . INT
    (20) auxTipo2 -> . BOOL
    (21) auxTipo2 -> . STRING
    (22) auxTipo2 -> . FLOAT

    CHAR            shift and go to state 11
    INT             shift and go to state 16
    BOOL            shift and go to state 13
    STRING          shift and go to state 15
    FLOAT           shift and go to state 17

    auxTipo1                       shift and go to state 19
    auxTipo2                       shift and go to state 20
    tipo                           shift and go to state 87
    auxParametros                  shift and go to state 150

state 144

    (79) funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .

    CHAR            reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)
    INT             reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)
    BOOL            reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)
    STRING          reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)
    FLOAT           reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)
    LBRACE          reduce using rule 79 (funcion -> tipo FUNCTION addProcDirectoryFunc ID LPAREN auxFunction RPAREN bloque .)


state 145

    (87) ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .

    ID              reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)
    IF              reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)
    PRINT           reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)
    READ            reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)
    WHILE           reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)
    RBRACE          reduce using rule 87 (ciclo -> WHILE LPAREN expresion RPAREN bloque SEMICOLON .)


state 146

    (74) auxVarcte -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 151


state 147

    (75) auxVarcte -> LBRACKET exp . LBRACKET

    LBRACKET        shift and go to state 152


state 148

    (50) auxCondicion -> ELSE . bloque
    (23) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 25

    bloque                         shift and go to state 153

state 149

    (49) condicion -> IF LPAREN expresion RPAREN bloque auxCondicion . SEMICOLON

    SEMICOLON       shift and go to state 154


state 150

    (85) ambAuxParametros -> COMMA auxParametros .

    RPAREN          reduce using rule 85 (ambAuxParametros -> COMMA auxParametros .)


state 151

    (74) auxVarcte -> LPAREN exp RPAREN .

    MULTI           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    GTHAN           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    LTHAN           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    NOTEQUAL        reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    GETHAN          reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    LETHAN          reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 74 (auxVarcte -> LPAREN exp RPAREN .)


state 152

    (75) auxVarcte -> LBRACKET exp LBRACKET .

    MULTI           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    DIVIDE          reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    PLUS            reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    MINUS           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    GTHAN           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    LTHAN           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    NOTEQUAL        reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    GETHAN          reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    LETHAN          reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    EQUAL           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    COMMA           reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    RPAREN          reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    RBRACKET        reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    SEMICOLON       reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)
    LBRACKET        reduce using rule 75 (auxVarcte -> LBRACKET exp LBRACKET .)


state 153

    (50) auxCondicion -> ELSE bloque .

    SEMICOLON       reduce using rule 50 (auxCondicion -> ELSE bloque .)


state 154

    (49) condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .

    ID              reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)
    IF              reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)
    PRINT           reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)
    READ            reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)
    WHILE           reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)
    RBRACE          reduce using rule 49 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CTESTRING in state 50 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 115 resolved as shift
WARNING: reduce/reduce conflict in state 56 resolved using rule (auxLlamada -> <empty>)
WARNING: rejected rule (argumentos -> <empty>) in state 56
WARNING: Rule (argumentos -> <empty>) is never reduced
