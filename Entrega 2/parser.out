Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque
Rule 2     addProcedureDir -> <empty>
Rule 3     cicloVars -> vars cicloVars
Rule 4     cicloVars -> <empty>
Rule 5     vars -> createVariableDir VAR auxVar1
Rule 6     createVariableDir -> <empty>
Rule 7     auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON auxVar1
Rule 8     auxVar1 -> <empty>
Rule 9     addTypeGlobal -> <empty>
Rule 10    idVars -> ID addVariableDir ambIdVars
Rule 11    addVariableDir -> <empty>
Rule 12    ambIdVars -> COMMA idVars
Rule 13    ambIdVars -> <empty>
Rule 14    tipo -> INT ambAuxTipo1
Rule 15    tipo -> BOOL ambAuxTipo1
Rule 16    tipo -> STRING ambAuxTipo1
Rule 17    tipo -> FLOAT ambAuxTipo1
Rule 18    tipo -> CHAR ambAuxTipo1
Rule 19    ambAuxTipo1 -> LBRACKET CTEINT RBRACKET
Rule 20    ambAuxTipo1 -> <empty>
Rule 21    bloque -> LBRACE cicloBloque RBRACE
Rule 22    cicloBloque -> estatuto cicloBloque
Rule 23    cicloBloque -> <empty>
Rule 24    estatuto -> asignacion
Rule 25    estatuto -> condicion
Rule 26    estatuto -> escritura
Rule 27    estatuto -> lectura
Rule 28    estatuto -> llamada
Rule 29    estatuto -> ciclo
Rule 30    asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON
Rule 31    auxAsignacion1 -> LBRACKET exp RBRACKET
Rule 32    auxAsignacion1 -> <empty>
Rule 33    escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
Rule 34    auxEscritura1 -> auxEscritura2 ambAuxEscritura1
Rule 35    ambAuxEscritura1 -> COMMA auxEscritura1
Rule 36    ambAuxEscritura1 -> <empty>
Rule 37    auxEscritura2 -> exp
Rule 38    auxEscritura2 -> CTESTRING
Rule 39    expresion -> exp auxExpresion exp
Rule 40    expresion -> <empty>
Rule 41    auxExpresion -> GTHAN
Rule 42    auxExpresion -> LTHAN
Rule 43    auxExpresion -> NOTEQUAL
Rule 44    auxExpresion -> GETHAN
Rule 45    auxExpresion -> LETHAN
Rule 46    auxExpresion -> EQUAL
Rule 47    condicion -> IF LPAREN expresion RPAREN bloque auxCondicion
Rule 48    auxCondicion -> ELSE bloque
Rule 49    auxCondicion -> <empty>
Rule 50    exp -> cicloExp
Rule 51    cicloExp -> termino ambExp
Rule 52    ambExp -> auxExp cicloExp
Rule 53    ambExp -> <empty>
Rule 54    auxExp -> PLUS
Rule 55    auxExp -> MINUS
Rule 56    termino -> cicloTermino
Rule 57    cicloTermino -> factor ambCicloTermino
Rule 58    ambCicloTermino -> auxTermino cicloTermino
Rule 59    ambCicloTermino -> <empty>
Rule 60    auxTermino -> MULTI
Rule 61    auxTermino -> DIVIDE
Rule 62    factor -> LPAREN exp RPAREN
Rule 63    factor -> auxFactor varcte
Rule 64    auxFactor -> auxExp
Rule 65    auxFactor -> <empty>
Rule 66    varcte -> ID auxVarcte
Rule 67    varcte -> CTEINT
Rule 68    varcte -> CTEFLOAT
Rule 69    varcte -> CTECHAR
Rule 70    varcte -> CTEBOOL
Rule 71    varcte -> CTESTRING
Rule 72    auxVarcte -> LPAREN exp RPAREN
Rule 73    auxVarcte -> LBRACKET exp LBRACKET
Rule 74    auxVarcte -> <empty>
Rule 75    cicloFuncion -> funcion cicloFuncion
Rule 76    cicloFuncion -> <empty>
Rule 77    funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque
Rule 78    addProcDirectoryFunc -> <empty>
Rule 79    auxFunction -> parametros
Rule 80    auxFunction -> <empty>
Rule 81    parametros -> auxParametros
Rule 82    auxParametros -> tipo ID ambAuxParametros
Rule 83    ambAuxParametros -> COMMA auxParametros
Rule 84    ambAuxParametros -> <empty>
Rule 85    ciclo -> WHILE LPAREN expresion RPAREN bloque
Rule 86    llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON
Rule 87    auxLlamada -> argumentos
Rule 88    auxLlamada -> <empty>
Rule 89    argumentos -> auxArgumentos1
Rule 90    argumentos -> <empty>
Rule 91    auxArgumentos1 -> exp ambAuxArgumentos1
Rule 92    ambAuxArgumentos1 -> COMMA auxArgumentos1
Rule 93    ambAuxArgumentos1 -> <empty>
Rule 94    lectura -> READ LPAREN ID RPAREN SEMICOLON

Terminals, with rules where they appear

BOOL                 : 15
CHAR                 : 18
COLON                : 7
COMMA                : 12 35 83 92
CTEBOOL              : 70
CTECHAR              : 69
CTEFLOAT             : 68
CTEINT               : 19 67
CTESTRING            : 38 71
DIVIDE               : 61
ELSE                 : 48
EQUAL                : 46
EQUALA               : 30
FLOAT                : 17
FUNCTION             : 77
GETHAN               : 44
GTHAN                : 41
ID                   : 1 10 30 66 77 82 86 94
IF                   : 47
INT                  : 14
LBRACE               : 21
LBRACKET             : 19 31 73 73
LETHAN               : 45
LPAREN               : 33 47 62 72 77 85 86 94
LTHAN                : 42
MAIN                 : 1
MINUS                : 55
MULTI                : 60
NOTEQUAL             : 43
PLUS                 : 54
PRINT                : 33
PROGRAM              : 1
RBRACE               : 21
RBRACKET             : 19 31
READ                 : 94
RPAREN               : 33 47 62 72 77 85 86 94
SEMICOLON            : 1 7 30 33 86 94
STRING               : 16
VAR                  : 5
WHILE                : 85
error                : 

Nonterminals, with rules where they appear

addProcDirectoryFunc : 77
addProcedureDir      : 1
addTypeGlobal        : 7
addVariableDir       : 10
ambAuxArgumentos1    : 91
ambAuxEscritura1     : 34
ambAuxParametros     : 82
ambAuxTipo1          : 14 15 16 17 18
ambCicloTermino      : 57
ambExp               : 51
ambIdVars            : 10
argumentos           : 87
asignacion           : 24
auxArgumentos1       : 89 92
auxAsignacion1       : 30
auxCondicion         : 47
auxEscritura1        : 33 35
auxEscritura2        : 34
auxExp               : 52 64
auxExpresion         : 39
auxFactor            : 63
auxFunction          : 77
auxLlamada           : 86
auxParametros        : 81 83
auxTermino           : 58
auxVar1              : 5 7
auxVarcte            : 66
bloque               : 1 47 48 77 85
ciclo                : 29
cicloBloque          : 21 22
cicloExp             : 50 52
cicloFuncion         : 1 75
cicloTermino         : 56 58
cicloVars            : 1 3
condicion            : 25
createVariableDir    : 5
escritura            : 26
estatuto             : 22
exp                  : 30 31 37 39 39 62 72 73 91
expresion            : 47 85
factor               : 57
funcion              : 75
idVars               : 7 12
lectura              : 27
llamada              : 28
parametros           : 79
programa             : 0
termino              : 51
tipo                 : 7 77 82
varcte               : 63
vars                 : 3

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque

    PROGRAM         shift and go to state 1

    programa                       shift and go to state 2

state 1

    (1) programa -> PROGRAM . ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque

    ID              shift and go to state 3


state 2

    (0) S' -> programa .



state 3

    (1) programa -> PROGRAM ID . addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque
    (2) addProcedureDir -> .

    SEMICOLON       reduce using rule 2 (addProcedureDir -> .)

    addProcedureDir                shift and go to state 4

state 4

    (1) programa -> PROGRAM ID addProcedureDir . SEMICOLON cicloVars cicloFuncion MAIN bloque

    SEMICOLON       shift and go to state 5


state 5

    (1) programa -> PROGRAM ID addProcedureDir SEMICOLON . cicloVars cicloFuncion MAIN bloque
    (3) cicloVars -> . vars cicloVars
    (4) cicloVars -> .
    (5) vars -> . createVariableDir VAR auxVar1
    (6) createVariableDir -> .

    FUNCTION        reduce using rule 4 (cicloVars -> .)
    MAIN            reduce using rule 4 (cicloVars -> .)
    VAR             reduce using rule 6 (createVariableDir -> .)

    vars                           shift and go to state 6
    cicloVars                      shift and go to state 7
    createVariableDir              shift and go to state 8

state 6

    (3) cicloVars -> vars . cicloVars
    (3) cicloVars -> . vars cicloVars
    (4) cicloVars -> .
    (5) vars -> . createVariableDir VAR auxVar1
    (6) createVariableDir -> .

    FUNCTION        reduce using rule 4 (cicloVars -> .)
    MAIN            reduce using rule 4 (cicloVars -> .)
    VAR             reduce using rule 6 (createVariableDir -> .)

    createVariableDir              shift and go to state 8
    cicloVars                      shift and go to state 9
    vars                           shift and go to state 6

state 7

    (1) programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars . cicloFuncion MAIN bloque
    (75) cicloFuncion -> . funcion cicloFuncion
    (76) cicloFuncion -> .
    (77) funcion -> . FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque

    MAIN            reduce using rule 76 (cicloFuncion -> .)
    FUNCTION        shift and go to state 10

    cicloFuncion                   shift and go to state 11
    funcion                        shift and go to state 12

state 8

    (5) vars -> createVariableDir . VAR auxVar1

    VAR             shift and go to state 13


state 9

    (3) cicloVars -> vars cicloVars .

    FUNCTION        reduce using rule 3 (cicloVars -> vars cicloVars .)
    MAIN            reduce using rule 3 (cicloVars -> vars cicloVars .)


state 10

    (77) funcion -> FUNCTION . tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque
    (14) tipo -> . INT ambAuxTipo1
    (15) tipo -> . BOOL ambAuxTipo1
    (16) tipo -> . STRING ambAuxTipo1
    (17) tipo -> . FLOAT ambAuxTipo1
    (18) tipo -> . CHAR ambAuxTipo1

    INT             shift and go to state 16
    BOOL            shift and go to state 19
    STRING          shift and go to state 14
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    tipo                           shift and go to state 15

state 11

    (1) programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion . MAIN bloque

    MAIN            shift and go to state 20


state 12

    (75) cicloFuncion -> funcion . cicloFuncion
    (75) cicloFuncion -> . funcion cicloFuncion
    (76) cicloFuncion -> .
    (77) funcion -> . FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque

    MAIN            reduce using rule 76 (cicloFuncion -> .)
    FUNCTION        shift and go to state 10

    cicloFuncion                   shift and go to state 21
    funcion                        shift and go to state 12

state 13

    (5) vars -> createVariableDir VAR . auxVar1
    (7) auxVar1 -> . idVars COLON tipo addTypeGlobal SEMICOLON auxVar1
    (8) auxVar1 -> .
    (10) idVars -> . ID addVariableDir ambIdVars

    VAR             reduce using rule 8 (auxVar1 -> .)
    FUNCTION        reduce using rule 8 (auxVar1 -> .)
    MAIN            reduce using rule 8 (auxVar1 -> .)
    ID              shift and go to state 24

    idVars                         shift and go to state 22
    auxVar1                        shift and go to state 23

state 14

    (16) tipo -> STRING . ambAuxTipo1
    (19) ambAuxTipo1 -> . LBRACKET CTEINT RBRACKET
    (20) ambAuxTipo1 -> .

    LBRACKET        shift and go to state 25
    ID              reduce using rule 20 (ambAuxTipo1 -> .)
    SEMICOLON       reduce using rule 20 (ambAuxTipo1 -> .)

    ambAuxTipo1                    shift and go to state 26

state 15

    (77) funcion -> FUNCTION tipo . ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque

    ID              shift and go to state 27


state 16

    (14) tipo -> INT . ambAuxTipo1
    (19) ambAuxTipo1 -> . LBRACKET CTEINT RBRACKET
    (20) ambAuxTipo1 -> .

    LBRACKET        shift and go to state 25
    ID              reduce using rule 20 (ambAuxTipo1 -> .)
    SEMICOLON       reduce using rule 20 (ambAuxTipo1 -> .)

    ambAuxTipo1                    shift and go to state 28

state 17

    (17) tipo -> FLOAT . ambAuxTipo1
    (19) ambAuxTipo1 -> . LBRACKET CTEINT RBRACKET
    (20) ambAuxTipo1 -> .

    LBRACKET        shift and go to state 25
    ID              reduce using rule 20 (ambAuxTipo1 -> .)
    SEMICOLON       reduce using rule 20 (ambAuxTipo1 -> .)

    ambAuxTipo1                    shift and go to state 29

state 18

    (18) tipo -> CHAR . ambAuxTipo1
    (19) ambAuxTipo1 -> . LBRACKET CTEINT RBRACKET
    (20) ambAuxTipo1 -> .

    LBRACKET        shift and go to state 25
    ID              reduce using rule 20 (ambAuxTipo1 -> .)
    SEMICOLON       reduce using rule 20 (ambAuxTipo1 -> .)

    ambAuxTipo1                    shift and go to state 30

state 19

    (15) tipo -> BOOL . ambAuxTipo1
    (19) ambAuxTipo1 -> . LBRACKET CTEINT RBRACKET
    (20) ambAuxTipo1 -> .

    LBRACKET        shift and go to state 25
    ID              reduce using rule 20 (ambAuxTipo1 -> .)
    SEMICOLON       reduce using rule 20 (ambAuxTipo1 -> .)

    ambAuxTipo1                    shift and go to state 31

state 20

    (1) programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN . bloque
    (21) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 32

    bloque                         shift and go to state 33

state 21

    (75) cicloFuncion -> funcion cicloFuncion .

    MAIN            reduce using rule 75 (cicloFuncion -> funcion cicloFuncion .)


state 22

    (7) auxVar1 -> idVars . COLON tipo addTypeGlobal SEMICOLON auxVar1

    COLON           shift and go to state 34


state 23

    (5) vars -> createVariableDir VAR auxVar1 .

    VAR             reduce using rule 5 (vars -> createVariableDir VAR auxVar1 .)
    FUNCTION        reduce using rule 5 (vars -> createVariableDir VAR auxVar1 .)
    MAIN            reduce using rule 5 (vars -> createVariableDir VAR auxVar1 .)


state 24

    (10) idVars -> ID . addVariableDir ambIdVars
    (11) addVariableDir -> .

    COMMA           reduce using rule 11 (addVariableDir -> .)
    COLON           reduce using rule 11 (addVariableDir -> .)

    addVariableDir                 shift and go to state 35

state 25

    (19) ambAuxTipo1 -> LBRACKET . CTEINT RBRACKET

    CTEINT          shift and go to state 36


state 26

    (16) tipo -> STRING ambAuxTipo1 .

    ID              reduce using rule 16 (tipo -> STRING ambAuxTipo1 .)
    SEMICOLON       reduce using rule 16 (tipo -> STRING ambAuxTipo1 .)


state 27

    (77) funcion -> FUNCTION tipo ID . addProcDirectoryFunc LPAREN auxFunction RPAREN bloque
    (78) addProcDirectoryFunc -> .

    LPAREN          reduce using rule 78 (addProcDirectoryFunc -> .)

    addProcDirectoryFunc           shift and go to state 37

state 28

    (14) tipo -> INT ambAuxTipo1 .

    ID              reduce using rule 14 (tipo -> INT ambAuxTipo1 .)
    SEMICOLON       reduce using rule 14 (tipo -> INT ambAuxTipo1 .)


state 29

    (17) tipo -> FLOAT ambAuxTipo1 .

    ID              reduce using rule 17 (tipo -> FLOAT ambAuxTipo1 .)
    SEMICOLON       reduce using rule 17 (tipo -> FLOAT ambAuxTipo1 .)


state 30

    (18) tipo -> CHAR ambAuxTipo1 .

    ID              reduce using rule 18 (tipo -> CHAR ambAuxTipo1 .)
    SEMICOLON       reduce using rule 18 (tipo -> CHAR ambAuxTipo1 .)


state 31

    (15) tipo -> BOOL ambAuxTipo1 .

    ID              reduce using rule 15 (tipo -> BOOL ambAuxTipo1 .)
    SEMICOLON       reduce using rule 15 (tipo -> BOOL ambAuxTipo1 .)


state 32

    (21) bloque -> LBRACE . cicloBloque RBRACE
    (22) cicloBloque -> . estatuto cicloBloque
    (23) cicloBloque -> .
    (24) estatuto -> . asignacion
    (25) estatuto -> . condicion
    (26) estatuto -> . escritura
    (27) estatuto -> . lectura
    (28) estatuto -> . llamada
    (29) estatuto -> . ciclo
    (30) asignacion -> . ID auxAsignacion1 EQUALA exp SEMICOLON
    (47) condicion -> . IF LPAREN expresion RPAREN bloque auxCondicion
    (33) escritura -> . PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
    (94) lectura -> . READ LPAREN ID RPAREN SEMICOLON
    (86) llamada -> . ID LPAREN auxLlamada RPAREN SEMICOLON
    (85) ciclo -> . WHILE LPAREN expresion RPAREN bloque

    RBRACE          reduce using rule 23 (cicloBloque -> .)
    ID              shift and go to state 48
    IF              shift and go to state 45
    PRINT           shift and go to state 40
    READ            shift and go to state 38
    WHILE           shift and go to state 39

    ciclo                          shift and go to state 41
    asignacion                     shift and go to state 49
    estatuto                       shift and go to state 42
    llamada                        shift and go to state 43
    condicion                      shift and go to state 44
    cicloBloque                    shift and go to state 47
    lectura                        shift and go to state 46
    escritura                      shift and go to state 50

state 33

    (1) programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque .

    $end            reduce using rule 1 (programa -> PROGRAM ID addProcedureDir SEMICOLON cicloVars cicloFuncion MAIN bloque .)


state 34

    (7) auxVar1 -> idVars COLON . tipo addTypeGlobal SEMICOLON auxVar1
    (14) tipo -> . INT ambAuxTipo1
    (15) tipo -> . BOOL ambAuxTipo1
    (16) tipo -> . STRING ambAuxTipo1
    (17) tipo -> . FLOAT ambAuxTipo1
    (18) tipo -> . CHAR ambAuxTipo1

    INT             shift and go to state 16
    BOOL            shift and go to state 19
    STRING          shift and go to state 14
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    tipo                           shift and go to state 51

state 35

    (10) idVars -> ID addVariableDir . ambIdVars
    (12) ambIdVars -> . COMMA idVars
    (13) ambIdVars -> .

    COMMA           shift and go to state 53
    COLON           reduce using rule 13 (ambIdVars -> .)

    ambIdVars                      shift and go to state 52

state 36

    (19) ambAuxTipo1 -> LBRACKET CTEINT . RBRACKET

    RBRACKET        shift and go to state 54


state 37

    (77) funcion -> FUNCTION tipo ID addProcDirectoryFunc . LPAREN auxFunction RPAREN bloque

    LPAREN          shift and go to state 55


state 38

    (94) lectura -> READ . LPAREN ID RPAREN SEMICOLON

    LPAREN          shift and go to state 56


state 39

    (85) ciclo -> WHILE . LPAREN expresion RPAREN bloque

    LPAREN          shift and go to state 57


state 40

    (33) escritura -> PRINT . LPAREN auxEscritura1 RPAREN SEMICOLON

    LPAREN          shift and go to state 58


state 41

    (29) estatuto -> ciclo .

    ID              reduce using rule 29 (estatuto -> ciclo .)
    IF              reduce using rule 29 (estatuto -> ciclo .)
    PRINT           reduce using rule 29 (estatuto -> ciclo .)
    READ            reduce using rule 29 (estatuto -> ciclo .)
    WHILE           reduce using rule 29 (estatuto -> ciclo .)
    RBRACE          reduce using rule 29 (estatuto -> ciclo .)


state 42

    (22) cicloBloque -> estatuto . cicloBloque
    (22) cicloBloque -> . estatuto cicloBloque
    (23) cicloBloque -> .
    (24) estatuto -> . asignacion
    (25) estatuto -> . condicion
    (26) estatuto -> . escritura
    (27) estatuto -> . lectura
    (28) estatuto -> . llamada
    (29) estatuto -> . ciclo
    (30) asignacion -> . ID auxAsignacion1 EQUALA exp SEMICOLON
    (47) condicion -> . IF LPAREN expresion RPAREN bloque auxCondicion
    (33) escritura -> . PRINT LPAREN auxEscritura1 RPAREN SEMICOLON
    (94) lectura -> . READ LPAREN ID RPAREN SEMICOLON
    (86) llamada -> . ID LPAREN auxLlamada RPAREN SEMICOLON
    (85) ciclo -> . WHILE LPAREN expresion RPAREN bloque

    RBRACE          reduce using rule 23 (cicloBloque -> .)
    ID              shift and go to state 48
    IF              shift and go to state 45
    PRINT           shift and go to state 40
    READ            shift and go to state 38
    WHILE           shift and go to state 39

    ciclo                          shift and go to state 41
    asignacion                     shift and go to state 49
    estatuto                       shift and go to state 42
    llamada                        shift and go to state 43
    condicion                      shift and go to state 44
    cicloBloque                    shift and go to state 59
    lectura                        shift and go to state 46
    escritura                      shift and go to state 50

state 43

    (28) estatuto -> llamada .

    ID              reduce using rule 28 (estatuto -> llamada .)
    IF              reduce using rule 28 (estatuto -> llamada .)
    PRINT           reduce using rule 28 (estatuto -> llamada .)
    READ            reduce using rule 28 (estatuto -> llamada .)
    WHILE           reduce using rule 28 (estatuto -> llamada .)
    RBRACE          reduce using rule 28 (estatuto -> llamada .)


state 44

    (25) estatuto -> condicion .

    ID              reduce using rule 25 (estatuto -> condicion .)
    IF              reduce using rule 25 (estatuto -> condicion .)
    PRINT           reduce using rule 25 (estatuto -> condicion .)
    READ            reduce using rule 25 (estatuto -> condicion .)
    WHILE           reduce using rule 25 (estatuto -> condicion .)
    RBRACE          reduce using rule 25 (estatuto -> condicion .)


state 45

    (47) condicion -> IF . LPAREN expresion RPAREN bloque auxCondicion

    LPAREN          shift and go to state 60


state 46

    (27) estatuto -> lectura .

    ID              reduce using rule 27 (estatuto -> lectura .)
    IF              reduce using rule 27 (estatuto -> lectura .)
    PRINT           reduce using rule 27 (estatuto -> lectura .)
    READ            reduce using rule 27 (estatuto -> lectura .)
    WHILE           reduce using rule 27 (estatuto -> lectura .)
    RBRACE          reduce using rule 27 (estatuto -> lectura .)


state 47

    (21) bloque -> LBRACE cicloBloque . RBRACE

    RBRACE          shift and go to state 61


state 48

    (30) asignacion -> ID . auxAsignacion1 EQUALA exp SEMICOLON
    (86) llamada -> ID . LPAREN auxLlamada RPAREN SEMICOLON
    (31) auxAsignacion1 -> . LBRACKET exp RBRACKET
    (32) auxAsignacion1 -> .

    LPAREN          shift and go to state 64
    LBRACKET        shift and go to state 62
    EQUALA          reduce using rule 32 (auxAsignacion1 -> .)

    auxAsignacion1                 shift and go to state 63

state 49

    (24) estatuto -> asignacion .

    ID              reduce using rule 24 (estatuto -> asignacion .)
    IF              reduce using rule 24 (estatuto -> asignacion .)
    PRINT           reduce using rule 24 (estatuto -> asignacion .)
    READ            reduce using rule 24 (estatuto -> asignacion .)
    WHILE           reduce using rule 24 (estatuto -> asignacion .)
    RBRACE          reduce using rule 24 (estatuto -> asignacion .)


state 50

    (26) estatuto -> escritura .

    ID              reduce using rule 26 (estatuto -> escritura .)
    IF              reduce using rule 26 (estatuto -> escritura .)
    PRINT           reduce using rule 26 (estatuto -> escritura .)
    READ            reduce using rule 26 (estatuto -> escritura .)
    WHILE           reduce using rule 26 (estatuto -> escritura .)
    RBRACE          reduce using rule 26 (estatuto -> escritura .)


state 51

    (7) auxVar1 -> idVars COLON tipo . addTypeGlobal SEMICOLON auxVar1
    (9) addTypeGlobal -> .

    SEMICOLON       reduce using rule 9 (addTypeGlobal -> .)

    addTypeGlobal                  shift and go to state 65

state 52

    (10) idVars -> ID addVariableDir ambIdVars .

    COLON           reduce using rule 10 (idVars -> ID addVariableDir ambIdVars .)


state 53

    (12) ambIdVars -> COMMA . idVars
    (10) idVars -> . ID addVariableDir ambIdVars

    ID              shift and go to state 24

    idVars                         shift and go to state 66

state 54

    (19) ambAuxTipo1 -> LBRACKET CTEINT RBRACKET .

    ID              reduce using rule 19 (ambAuxTipo1 -> LBRACKET CTEINT RBRACKET .)
    SEMICOLON       reduce using rule 19 (ambAuxTipo1 -> LBRACKET CTEINT RBRACKET .)


state 55

    (77) funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN . auxFunction RPAREN bloque
    (79) auxFunction -> . parametros
    (80) auxFunction -> .
    (81) parametros -> . auxParametros
    (82) auxParametros -> . tipo ID ambAuxParametros
    (14) tipo -> . INT ambAuxTipo1
    (15) tipo -> . BOOL ambAuxTipo1
    (16) tipo -> . STRING ambAuxTipo1
    (17) tipo -> . FLOAT ambAuxTipo1
    (18) tipo -> . CHAR ambAuxTipo1

    RPAREN          reduce using rule 80 (auxFunction -> .)
    INT             shift and go to state 16
    BOOL            shift and go to state 19
    STRING          shift and go to state 14
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    tipo                           shift and go to state 67
    auxFunction                    shift and go to state 68
    auxParametros                  shift and go to state 69
    parametros                     shift and go to state 70

state 56

    (94) lectura -> READ LPAREN . ID RPAREN SEMICOLON

    ID              shift and go to state 71


state 57

    (85) ciclo -> WHILE LPAREN . expresion RPAREN bloque
    (39) expresion -> . exp auxExpresion exp
    (40) expresion -> .
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    RPAREN          reduce using rule 40 (expresion -> .)
    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    expresion                      shift and go to state 72
    auxExp                         shift and go to state 74
    auxFactor                      shift and go to state 75
    termino                        shift and go to state 77
    exp                            shift and go to state 78
    factor                         shift and go to state 79
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 58

    (33) escritura -> PRINT LPAREN . auxEscritura1 RPAREN SEMICOLON
    (34) auxEscritura1 -> . auxEscritura2 ambAuxEscritura1
    (37) auxEscritura2 -> . exp
    (38) auxEscritura2 -> . CTESTRING
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

  ! shift/reduce conflict for CTESTRING resolved as shift
    CTESTRING       shift and go to state 86
    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

  ! CTESTRING       [ reduce using rule 65 (auxFactor -> .) ]

    auxEscritura1                  shift and go to state 84
    auxEscritura2                  shift and go to state 85
    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 83
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 59

    (22) cicloBloque -> estatuto cicloBloque .

    RBRACE          reduce using rule 22 (cicloBloque -> estatuto cicloBloque .)


state 60

    (47) condicion -> IF LPAREN . expresion RPAREN bloque auxCondicion
    (39) expresion -> . exp auxExpresion exp
    (40) expresion -> .
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    RPAREN          reduce using rule 40 (expresion -> .)
    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    expresion                      shift and go to state 87
    auxExp                         shift and go to state 74
    auxFactor                      shift and go to state 75
    termino                        shift and go to state 77
    exp                            shift and go to state 78
    factor                         shift and go to state 79
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 61

    (21) bloque -> LBRACE cicloBloque RBRACE .

    ELSE            reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    ID              reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    IF              reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    PRINT           reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    READ            reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    WHILE           reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    RBRACE          reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    $end            reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    FUNCTION        reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)
    MAIN            reduce using rule 21 (bloque -> LBRACE cicloBloque RBRACE .)


state 62

    (31) auxAsignacion1 -> LBRACKET . exp RBRACKET
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 88
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 63

    (30) asignacion -> ID auxAsignacion1 . EQUALA exp SEMICOLON

    EQUALA          shift and go to state 89


state 64

    (86) llamada -> ID LPAREN . auxLlamada RPAREN SEMICOLON
    (87) auxLlamada -> . argumentos
    (88) auxLlamada -> .
    (89) argumentos -> . auxArgumentos1
    (90) argumentos -> .
    (91) auxArgumentos1 -> . exp ambAuxArgumentos1
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

  ! reduce/reduce conflict for RPAREN resolved using rule 88 (auxLlamada -> .)
    RPAREN          reduce using rule 88 (auxLlamada -> .)
    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

  ! RPAREN          [ reduce using rule 90 (argumentos -> .) ]

    auxLlamada                     shift and go to state 91
    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 90
    factor                         shift and go to state 79
    argumentos                     shift and go to state 92
    auxFactor                      shift and go to state 75
    auxArgumentos1                 shift and go to state 93
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 65

    (7) auxVar1 -> idVars COLON tipo addTypeGlobal . SEMICOLON auxVar1

    SEMICOLON       shift and go to state 94


state 66

    (12) ambIdVars -> COMMA idVars .

    COLON           reduce using rule 12 (ambIdVars -> COMMA idVars .)


state 67

    (82) auxParametros -> tipo . ID ambAuxParametros

    ID              shift and go to state 95


state 68

    (77) funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction . RPAREN bloque

    RPAREN          shift and go to state 96


state 69

    (81) parametros -> auxParametros .

    RPAREN          reduce using rule 81 (parametros -> auxParametros .)


state 70

    (79) auxFunction -> parametros .

    RPAREN          reduce using rule 79 (auxFunction -> parametros .)


state 71

    (94) lectura -> READ LPAREN ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 97


state 72

    (85) ciclo -> WHILE LPAREN expresion . RPAREN bloque

    RPAREN          shift and go to state 98


state 73

    (62) factor -> LPAREN . exp RPAREN
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 99
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 74

    (64) auxFactor -> auxExp .

    ID              reduce using rule 64 (auxFactor -> auxExp .)
    CTEINT          reduce using rule 64 (auxFactor -> auxExp .)
    CTEFLOAT        reduce using rule 64 (auxFactor -> auxExp .)
    CTECHAR         reduce using rule 64 (auxFactor -> auxExp .)
    CTEBOOL         reduce using rule 64 (auxFactor -> auxExp .)
    CTESTRING       reduce using rule 64 (auxFactor -> auxExp .)


state 75

    (63) factor -> auxFactor . varcte
    (66) varcte -> . ID auxVarcte
    (67) varcte -> . CTEINT
    (68) varcte -> . CTEFLOAT
    (69) varcte -> . CTECHAR
    (70) varcte -> . CTEBOOL
    (71) varcte -> . CTESTRING

    ID              shift and go to state 106
    CTEINT          shift and go to state 103
    CTEFLOAT        shift and go to state 104
    CTECHAR         shift and go to state 105
    CTEBOOL         shift and go to state 102
    CTESTRING       shift and go to state 100

    varcte                         shift and go to state 101

state 76

    (54) auxExp -> PLUS .

    ID              reduce using rule 54 (auxExp -> PLUS .)
    CTEINT          reduce using rule 54 (auxExp -> PLUS .)
    CTEFLOAT        reduce using rule 54 (auxExp -> PLUS .)
    CTECHAR         reduce using rule 54 (auxExp -> PLUS .)
    CTEBOOL         reduce using rule 54 (auxExp -> PLUS .)
    CTESTRING       reduce using rule 54 (auxExp -> PLUS .)
    LPAREN          reduce using rule 54 (auxExp -> PLUS .)
    PLUS            reduce using rule 54 (auxExp -> PLUS .)
    MINUS           reduce using rule 54 (auxExp -> PLUS .)


state 77

    (51) cicloExp -> termino . ambExp
    (52) ambExp -> . auxExp cicloExp
    (53) ambExp -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    GTHAN           reduce using rule 53 (ambExp -> .)
    LTHAN           reduce using rule 53 (ambExp -> .)
    NOTEQUAL        reduce using rule 53 (ambExp -> .)
    GETHAN          reduce using rule 53 (ambExp -> .)
    LETHAN          reduce using rule 53 (ambExp -> .)
    EQUAL           reduce using rule 53 (ambExp -> .)
    COMMA           reduce using rule 53 (ambExp -> .)
    RPAREN          reduce using rule 53 (ambExp -> .)
    RBRACKET        reduce using rule 53 (ambExp -> .)
    SEMICOLON       reduce using rule 53 (ambExp -> .)
    LBRACKET        reduce using rule 53 (ambExp -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    ambExp                         shift and go to state 108
    auxExp                         shift and go to state 107

state 78

    (39) expresion -> exp . auxExpresion exp
    (41) auxExpresion -> . GTHAN
    (42) auxExpresion -> . LTHAN
    (43) auxExpresion -> . NOTEQUAL
    (44) auxExpresion -> . GETHAN
    (45) auxExpresion -> . LETHAN
    (46) auxExpresion -> . EQUAL

    GTHAN           shift and go to state 111
    LTHAN           shift and go to state 114
    NOTEQUAL        shift and go to state 109
    GETHAN          shift and go to state 113
    LETHAN          shift and go to state 115
    EQUAL           shift and go to state 112

    auxExpresion                   shift and go to state 110

state 79

    (57) cicloTermino -> factor . ambCicloTermino
    (58) ambCicloTermino -> . auxTermino cicloTermino
    (59) ambCicloTermino -> .
    (60) auxTermino -> . MULTI
    (61) auxTermino -> . DIVIDE

    PLUS            reduce using rule 59 (ambCicloTermino -> .)
    MINUS           reduce using rule 59 (ambCicloTermino -> .)
    GTHAN           reduce using rule 59 (ambCicloTermino -> .)
    LTHAN           reduce using rule 59 (ambCicloTermino -> .)
    NOTEQUAL        reduce using rule 59 (ambCicloTermino -> .)
    GETHAN          reduce using rule 59 (ambCicloTermino -> .)
    LETHAN          reduce using rule 59 (ambCicloTermino -> .)
    EQUAL           reduce using rule 59 (ambCicloTermino -> .)
    COMMA           reduce using rule 59 (ambCicloTermino -> .)
    RPAREN          reduce using rule 59 (ambCicloTermino -> .)
    RBRACKET        reduce using rule 59 (ambCicloTermino -> .)
    SEMICOLON       reduce using rule 59 (ambCicloTermino -> .)
    LBRACKET        reduce using rule 59 (ambCicloTermino -> .)
    MULTI           shift and go to state 116
    DIVIDE          shift and go to state 117

    ambCicloTermino                shift and go to state 119
    auxTermino                     shift and go to state 118

state 80

    (55) auxExp -> MINUS .

    ID              reduce using rule 55 (auxExp -> MINUS .)
    CTEINT          reduce using rule 55 (auxExp -> MINUS .)
    CTEFLOAT        reduce using rule 55 (auxExp -> MINUS .)
    CTECHAR         reduce using rule 55 (auxExp -> MINUS .)
    CTEBOOL         reduce using rule 55 (auxExp -> MINUS .)
    CTESTRING       reduce using rule 55 (auxExp -> MINUS .)
    LPAREN          reduce using rule 55 (auxExp -> MINUS .)
    PLUS            reduce using rule 55 (auxExp -> MINUS .)
    MINUS           reduce using rule 55 (auxExp -> MINUS .)


state 81

    (50) exp -> cicloExp .

    SEMICOLON       reduce using rule 50 (exp -> cicloExp .)
    GTHAN           reduce using rule 50 (exp -> cicloExp .)
    LTHAN           reduce using rule 50 (exp -> cicloExp .)
    NOTEQUAL        reduce using rule 50 (exp -> cicloExp .)
    GETHAN          reduce using rule 50 (exp -> cicloExp .)
    LETHAN          reduce using rule 50 (exp -> cicloExp .)
    EQUAL           reduce using rule 50 (exp -> cicloExp .)
    RBRACKET        reduce using rule 50 (exp -> cicloExp .)
    RPAREN          reduce using rule 50 (exp -> cicloExp .)
    COMMA           reduce using rule 50 (exp -> cicloExp .)
    LBRACKET        reduce using rule 50 (exp -> cicloExp .)


state 82

    (56) termino -> cicloTermino .

    PLUS            reduce using rule 56 (termino -> cicloTermino .)
    MINUS           reduce using rule 56 (termino -> cicloTermino .)
    GTHAN           reduce using rule 56 (termino -> cicloTermino .)
    LTHAN           reduce using rule 56 (termino -> cicloTermino .)
    NOTEQUAL        reduce using rule 56 (termino -> cicloTermino .)
    GETHAN          reduce using rule 56 (termino -> cicloTermino .)
    LETHAN          reduce using rule 56 (termino -> cicloTermino .)
    EQUAL           reduce using rule 56 (termino -> cicloTermino .)
    LBRACKET        reduce using rule 56 (termino -> cicloTermino .)
    COMMA           reduce using rule 56 (termino -> cicloTermino .)
    RPAREN          reduce using rule 56 (termino -> cicloTermino .)
    RBRACKET        reduce using rule 56 (termino -> cicloTermino .)
    SEMICOLON       reduce using rule 56 (termino -> cicloTermino .)


state 83

    (37) auxEscritura2 -> exp .

    COMMA           reduce using rule 37 (auxEscritura2 -> exp .)
    RPAREN          reduce using rule 37 (auxEscritura2 -> exp .)


state 84

    (33) escritura -> PRINT LPAREN auxEscritura1 . RPAREN SEMICOLON

    RPAREN          shift and go to state 120


state 85

    (34) auxEscritura1 -> auxEscritura2 . ambAuxEscritura1
    (35) ambAuxEscritura1 -> . COMMA auxEscritura1
    (36) ambAuxEscritura1 -> .

    COMMA           shift and go to state 121
    RPAREN          reduce using rule 36 (ambAuxEscritura1 -> .)

    ambAuxEscritura1               shift and go to state 122

state 86

    (38) auxEscritura2 -> CTESTRING .

    COMMA           reduce using rule 38 (auxEscritura2 -> CTESTRING .)
    RPAREN          reduce using rule 38 (auxEscritura2 -> CTESTRING .)


state 87

    (47) condicion -> IF LPAREN expresion . RPAREN bloque auxCondicion

    RPAREN          shift and go to state 123


state 88

    (31) auxAsignacion1 -> LBRACKET exp . RBRACKET

    RBRACKET        shift and go to state 124


state 89

    (30) asignacion -> ID auxAsignacion1 EQUALA . exp SEMICOLON
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 125
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 90

    (91) auxArgumentos1 -> exp . ambAuxArgumentos1
    (92) ambAuxArgumentos1 -> . COMMA auxArgumentos1
    (93) ambAuxArgumentos1 -> .

    COMMA           shift and go to state 127
    RPAREN          reduce using rule 93 (ambAuxArgumentos1 -> .)

    ambAuxArgumentos1              shift and go to state 126

state 91

    (86) llamada -> ID LPAREN auxLlamada . RPAREN SEMICOLON

    RPAREN          shift and go to state 128


state 92

    (87) auxLlamada -> argumentos .

    RPAREN          reduce using rule 87 (auxLlamada -> argumentos .)


state 93

    (89) argumentos -> auxArgumentos1 .

    RPAREN          reduce using rule 89 (argumentos -> auxArgumentos1 .)


state 94

    (7) auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON . auxVar1
    (7) auxVar1 -> . idVars COLON tipo addTypeGlobal SEMICOLON auxVar1
    (8) auxVar1 -> .
    (10) idVars -> . ID addVariableDir ambIdVars

    VAR             reduce using rule 8 (auxVar1 -> .)
    FUNCTION        reduce using rule 8 (auxVar1 -> .)
    MAIN            reduce using rule 8 (auxVar1 -> .)
    ID              shift and go to state 24

    idVars                         shift and go to state 22
    auxVar1                        shift and go to state 129

state 95

    (82) auxParametros -> tipo ID . ambAuxParametros
    (83) ambAuxParametros -> . COMMA auxParametros
    (84) ambAuxParametros -> .

    COMMA           shift and go to state 131
    RPAREN          reduce using rule 84 (ambAuxParametros -> .)

    ambAuxParametros               shift and go to state 130

state 96

    (77) funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN . bloque
    (21) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 32

    bloque                         shift and go to state 132

state 97

    (94) lectura -> READ LPAREN ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 133


state 98

    (85) ciclo -> WHILE LPAREN expresion RPAREN . bloque
    (21) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 32

    bloque                         shift and go to state 134

state 99

    (62) factor -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 135


state 100

    (71) varcte -> CTESTRING .

    MULTI           reduce using rule 71 (varcte -> CTESTRING .)
    DIVIDE          reduce using rule 71 (varcte -> CTESTRING .)
    PLUS            reduce using rule 71 (varcte -> CTESTRING .)
    MINUS           reduce using rule 71 (varcte -> CTESTRING .)
    GTHAN           reduce using rule 71 (varcte -> CTESTRING .)
    LTHAN           reduce using rule 71 (varcte -> CTESTRING .)
    NOTEQUAL        reduce using rule 71 (varcte -> CTESTRING .)
    GETHAN          reduce using rule 71 (varcte -> CTESTRING .)
    LETHAN          reduce using rule 71 (varcte -> CTESTRING .)
    EQUAL           reduce using rule 71 (varcte -> CTESTRING .)
    COMMA           reduce using rule 71 (varcte -> CTESTRING .)
    RPAREN          reduce using rule 71 (varcte -> CTESTRING .)
    RBRACKET        reduce using rule 71 (varcte -> CTESTRING .)
    SEMICOLON       reduce using rule 71 (varcte -> CTESTRING .)
    LBRACKET        reduce using rule 71 (varcte -> CTESTRING .)


state 101

    (63) factor -> auxFactor varcte .

    MULTI           reduce using rule 63 (factor -> auxFactor varcte .)
    DIVIDE          reduce using rule 63 (factor -> auxFactor varcte .)
    PLUS            reduce using rule 63 (factor -> auxFactor varcte .)
    MINUS           reduce using rule 63 (factor -> auxFactor varcte .)
    LBRACKET        reduce using rule 63 (factor -> auxFactor varcte .)
    COMMA           reduce using rule 63 (factor -> auxFactor varcte .)
    RPAREN          reduce using rule 63 (factor -> auxFactor varcte .)
    GTHAN           reduce using rule 63 (factor -> auxFactor varcte .)
    LTHAN           reduce using rule 63 (factor -> auxFactor varcte .)
    NOTEQUAL        reduce using rule 63 (factor -> auxFactor varcte .)
    GETHAN          reduce using rule 63 (factor -> auxFactor varcte .)
    LETHAN          reduce using rule 63 (factor -> auxFactor varcte .)
    EQUAL           reduce using rule 63 (factor -> auxFactor varcte .)
    RBRACKET        reduce using rule 63 (factor -> auxFactor varcte .)
    SEMICOLON       reduce using rule 63 (factor -> auxFactor varcte .)


state 102

    (70) varcte -> CTEBOOL .

    MULTI           reduce using rule 70 (varcte -> CTEBOOL .)
    DIVIDE          reduce using rule 70 (varcte -> CTEBOOL .)
    PLUS            reduce using rule 70 (varcte -> CTEBOOL .)
    MINUS           reduce using rule 70 (varcte -> CTEBOOL .)
    GTHAN           reduce using rule 70 (varcte -> CTEBOOL .)
    LTHAN           reduce using rule 70 (varcte -> CTEBOOL .)
    NOTEQUAL        reduce using rule 70 (varcte -> CTEBOOL .)
    GETHAN          reduce using rule 70 (varcte -> CTEBOOL .)
    LETHAN          reduce using rule 70 (varcte -> CTEBOOL .)
    EQUAL           reduce using rule 70 (varcte -> CTEBOOL .)
    COMMA           reduce using rule 70 (varcte -> CTEBOOL .)
    RPAREN          reduce using rule 70 (varcte -> CTEBOOL .)
    RBRACKET        reduce using rule 70 (varcte -> CTEBOOL .)
    SEMICOLON       reduce using rule 70 (varcte -> CTEBOOL .)
    LBRACKET        reduce using rule 70 (varcte -> CTEBOOL .)


state 103

    (67) varcte -> CTEINT .

    MULTI           reduce using rule 67 (varcte -> CTEINT .)
    DIVIDE          reduce using rule 67 (varcte -> CTEINT .)
    PLUS            reduce using rule 67 (varcte -> CTEINT .)
    MINUS           reduce using rule 67 (varcte -> CTEINT .)
    GTHAN           reduce using rule 67 (varcte -> CTEINT .)
    LTHAN           reduce using rule 67 (varcte -> CTEINT .)
    NOTEQUAL        reduce using rule 67 (varcte -> CTEINT .)
    GETHAN          reduce using rule 67 (varcte -> CTEINT .)
    LETHAN          reduce using rule 67 (varcte -> CTEINT .)
    EQUAL           reduce using rule 67 (varcte -> CTEINT .)
    COMMA           reduce using rule 67 (varcte -> CTEINT .)
    RPAREN          reduce using rule 67 (varcte -> CTEINT .)
    RBRACKET        reduce using rule 67 (varcte -> CTEINT .)
    SEMICOLON       reduce using rule 67 (varcte -> CTEINT .)
    LBRACKET        reduce using rule 67 (varcte -> CTEINT .)


state 104

    (68) varcte -> CTEFLOAT .

    MULTI           reduce using rule 68 (varcte -> CTEFLOAT .)
    DIVIDE          reduce using rule 68 (varcte -> CTEFLOAT .)
    PLUS            reduce using rule 68 (varcte -> CTEFLOAT .)
    MINUS           reduce using rule 68 (varcte -> CTEFLOAT .)
    GTHAN           reduce using rule 68 (varcte -> CTEFLOAT .)
    LTHAN           reduce using rule 68 (varcte -> CTEFLOAT .)
    NOTEQUAL        reduce using rule 68 (varcte -> CTEFLOAT .)
    GETHAN          reduce using rule 68 (varcte -> CTEFLOAT .)
    LETHAN          reduce using rule 68 (varcte -> CTEFLOAT .)
    EQUAL           reduce using rule 68 (varcte -> CTEFLOAT .)
    COMMA           reduce using rule 68 (varcte -> CTEFLOAT .)
    RPAREN          reduce using rule 68 (varcte -> CTEFLOAT .)
    RBRACKET        reduce using rule 68 (varcte -> CTEFLOAT .)
    SEMICOLON       reduce using rule 68 (varcte -> CTEFLOAT .)
    LBRACKET        reduce using rule 68 (varcte -> CTEFLOAT .)


state 105

    (69) varcte -> CTECHAR .

    MULTI           reduce using rule 69 (varcte -> CTECHAR .)
    DIVIDE          reduce using rule 69 (varcte -> CTECHAR .)
    PLUS            reduce using rule 69 (varcte -> CTECHAR .)
    MINUS           reduce using rule 69 (varcte -> CTECHAR .)
    GTHAN           reduce using rule 69 (varcte -> CTECHAR .)
    LTHAN           reduce using rule 69 (varcte -> CTECHAR .)
    NOTEQUAL        reduce using rule 69 (varcte -> CTECHAR .)
    GETHAN          reduce using rule 69 (varcte -> CTECHAR .)
    LETHAN          reduce using rule 69 (varcte -> CTECHAR .)
    EQUAL           reduce using rule 69 (varcte -> CTECHAR .)
    COMMA           reduce using rule 69 (varcte -> CTECHAR .)
    RPAREN          reduce using rule 69 (varcte -> CTECHAR .)
    RBRACKET        reduce using rule 69 (varcte -> CTECHAR .)
    SEMICOLON       reduce using rule 69 (varcte -> CTECHAR .)
    LBRACKET        reduce using rule 69 (varcte -> CTECHAR .)


state 106

    (66) varcte -> ID . auxVarcte
    (72) auxVarcte -> . LPAREN exp RPAREN
    (73) auxVarcte -> . LBRACKET exp LBRACKET
    (74) auxVarcte -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 136
    LBRACKET        shift and go to state 137
    MULTI           reduce using rule 74 (auxVarcte -> .)
    DIVIDE          reduce using rule 74 (auxVarcte -> .)
    PLUS            reduce using rule 74 (auxVarcte -> .)
    MINUS           reduce using rule 74 (auxVarcte -> .)
    GTHAN           reduce using rule 74 (auxVarcte -> .)
    LTHAN           reduce using rule 74 (auxVarcte -> .)
    NOTEQUAL        reduce using rule 74 (auxVarcte -> .)
    GETHAN          reduce using rule 74 (auxVarcte -> .)
    LETHAN          reduce using rule 74 (auxVarcte -> .)
    EQUAL           reduce using rule 74 (auxVarcte -> .)
    COMMA           reduce using rule 74 (auxVarcte -> .)
    RPAREN          reduce using rule 74 (auxVarcte -> .)
    RBRACKET        reduce using rule 74 (auxVarcte -> .)
    SEMICOLON       reduce using rule 74 (auxVarcte -> .)

  ! LBRACKET        [ reduce using rule 74 (auxVarcte -> .) ]

    auxVarcte                      shift and go to state 138

state 107

    (52) ambExp -> auxExp . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    cicloExp                       shift and go to state 139
    termino                        shift and go to state 77
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    auxExp                         shift and go to state 74
    cicloTermino                   shift and go to state 82

state 108

    (51) cicloExp -> termino ambExp .

    GTHAN           reduce using rule 51 (cicloExp -> termino ambExp .)
    LTHAN           reduce using rule 51 (cicloExp -> termino ambExp .)
    NOTEQUAL        reduce using rule 51 (cicloExp -> termino ambExp .)
    GETHAN          reduce using rule 51 (cicloExp -> termino ambExp .)
    LETHAN          reduce using rule 51 (cicloExp -> termino ambExp .)
    EQUAL           reduce using rule 51 (cicloExp -> termino ambExp .)
    COMMA           reduce using rule 51 (cicloExp -> termino ambExp .)
    RPAREN          reduce using rule 51 (cicloExp -> termino ambExp .)
    RBRACKET        reduce using rule 51 (cicloExp -> termino ambExp .)
    SEMICOLON       reduce using rule 51 (cicloExp -> termino ambExp .)
    LBRACKET        reduce using rule 51 (cicloExp -> termino ambExp .)


state 109

    (43) auxExpresion -> NOTEQUAL .

    LPAREN          reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    PLUS            reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    MINUS           reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    ID              reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    CTEINT          reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    CTEFLOAT        reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    CTECHAR         reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    CTEBOOL         reduce using rule 43 (auxExpresion -> NOTEQUAL .)
    CTESTRING       reduce using rule 43 (auxExpresion -> NOTEQUAL .)


state 110

    (39) expresion -> exp auxExpresion . exp
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 140
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 111

    (41) auxExpresion -> GTHAN .

    LPAREN          reduce using rule 41 (auxExpresion -> GTHAN .)
    PLUS            reduce using rule 41 (auxExpresion -> GTHAN .)
    MINUS           reduce using rule 41 (auxExpresion -> GTHAN .)
    ID              reduce using rule 41 (auxExpresion -> GTHAN .)
    CTEINT          reduce using rule 41 (auxExpresion -> GTHAN .)
    CTEFLOAT        reduce using rule 41 (auxExpresion -> GTHAN .)
    CTECHAR         reduce using rule 41 (auxExpresion -> GTHAN .)
    CTEBOOL         reduce using rule 41 (auxExpresion -> GTHAN .)
    CTESTRING       reduce using rule 41 (auxExpresion -> GTHAN .)


state 112

    (46) auxExpresion -> EQUAL .

    LPAREN          reduce using rule 46 (auxExpresion -> EQUAL .)
    PLUS            reduce using rule 46 (auxExpresion -> EQUAL .)
    MINUS           reduce using rule 46 (auxExpresion -> EQUAL .)
    ID              reduce using rule 46 (auxExpresion -> EQUAL .)
    CTEINT          reduce using rule 46 (auxExpresion -> EQUAL .)
    CTEFLOAT        reduce using rule 46 (auxExpresion -> EQUAL .)
    CTECHAR         reduce using rule 46 (auxExpresion -> EQUAL .)
    CTEBOOL         reduce using rule 46 (auxExpresion -> EQUAL .)
    CTESTRING       reduce using rule 46 (auxExpresion -> EQUAL .)


state 113

    (44) auxExpresion -> GETHAN .

    LPAREN          reduce using rule 44 (auxExpresion -> GETHAN .)
    PLUS            reduce using rule 44 (auxExpresion -> GETHAN .)
    MINUS           reduce using rule 44 (auxExpresion -> GETHAN .)
    ID              reduce using rule 44 (auxExpresion -> GETHAN .)
    CTEINT          reduce using rule 44 (auxExpresion -> GETHAN .)
    CTEFLOAT        reduce using rule 44 (auxExpresion -> GETHAN .)
    CTECHAR         reduce using rule 44 (auxExpresion -> GETHAN .)
    CTEBOOL         reduce using rule 44 (auxExpresion -> GETHAN .)
    CTESTRING       reduce using rule 44 (auxExpresion -> GETHAN .)


state 114

    (42) auxExpresion -> LTHAN .

    LPAREN          reduce using rule 42 (auxExpresion -> LTHAN .)
    PLUS            reduce using rule 42 (auxExpresion -> LTHAN .)
    MINUS           reduce using rule 42 (auxExpresion -> LTHAN .)
    ID              reduce using rule 42 (auxExpresion -> LTHAN .)
    CTEINT          reduce using rule 42 (auxExpresion -> LTHAN .)
    CTEFLOAT        reduce using rule 42 (auxExpresion -> LTHAN .)
    CTECHAR         reduce using rule 42 (auxExpresion -> LTHAN .)
    CTEBOOL         reduce using rule 42 (auxExpresion -> LTHAN .)
    CTESTRING       reduce using rule 42 (auxExpresion -> LTHAN .)


state 115

    (45) auxExpresion -> LETHAN .

    LPAREN          reduce using rule 45 (auxExpresion -> LETHAN .)
    PLUS            reduce using rule 45 (auxExpresion -> LETHAN .)
    MINUS           reduce using rule 45 (auxExpresion -> LETHAN .)
    ID              reduce using rule 45 (auxExpresion -> LETHAN .)
    CTEINT          reduce using rule 45 (auxExpresion -> LETHAN .)
    CTEFLOAT        reduce using rule 45 (auxExpresion -> LETHAN .)
    CTECHAR         reduce using rule 45 (auxExpresion -> LETHAN .)
    CTEBOOL         reduce using rule 45 (auxExpresion -> LETHAN .)
    CTESTRING       reduce using rule 45 (auxExpresion -> LETHAN .)


state 116

    (60) auxTermino -> MULTI .

    LPAREN          reduce using rule 60 (auxTermino -> MULTI .)
    PLUS            reduce using rule 60 (auxTermino -> MULTI .)
    MINUS           reduce using rule 60 (auxTermino -> MULTI .)
    ID              reduce using rule 60 (auxTermino -> MULTI .)
    CTEINT          reduce using rule 60 (auxTermino -> MULTI .)
    CTEFLOAT        reduce using rule 60 (auxTermino -> MULTI .)
    CTECHAR         reduce using rule 60 (auxTermino -> MULTI .)
    CTEBOOL         reduce using rule 60 (auxTermino -> MULTI .)
    CTESTRING       reduce using rule 60 (auxTermino -> MULTI .)


state 117

    (61) auxTermino -> DIVIDE .

    LPAREN          reduce using rule 61 (auxTermino -> DIVIDE .)
    PLUS            reduce using rule 61 (auxTermino -> DIVIDE .)
    MINUS           reduce using rule 61 (auxTermino -> DIVIDE .)
    ID              reduce using rule 61 (auxTermino -> DIVIDE .)
    CTEINT          reduce using rule 61 (auxTermino -> DIVIDE .)
    CTEFLOAT        reduce using rule 61 (auxTermino -> DIVIDE .)
    CTECHAR         reduce using rule 61 (auxTermino -> DIVIDE .)
    CTEBOOL         reduce using rule 61 (auxTermino -> DIVIDE .)
    CTESTRING       reduce using rule 61 (auxTermino -> DIVIDE .)


state 118

    (58) ambCicloTermino -> auxTermino . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    auxExp                         shift and go to state 74
    cicloTermino                   shift and go to state 141

state 119

    (57) cicloTermino -> factor ambCicloTermino .

    PLUS            reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    MINUS           reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    RPAREN          reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    SEMICOLON       reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    RBRACKET        reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    COMMA           reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    GTHAN           reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    LTHAN           reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    NOTEQUAL        reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    GETHAN          reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    LETHAN          reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    EQUAL           reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)
    LBRACKET        reduce using rule 57 (cicloTermino -> factor ambCicloTermino .)


state 120

    (33) escritura -> PRINT LPAREN auxEscritura1 RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 142


state 121

    (35) ambAuxEscritura1 -> COMMA . auxEscritura1
    (34) auxEscritura1 -> . auxEscritura2 ambAuxEscritura1
    (37) auxEscritura2 -> . exp
    (38) auxEscritura2 -> . CTESTRING
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

  ! shift/reduce conflict for CTESTRING resolved as shift
    CTESTRING       shift and go to state 86
    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

  ! CTESTRING       [ reduce using rule 65 (auxFactor -> .) ]

    auxEscritura1                  shift and go to state 143
    auxEscritura2                  shift and go to state 85
    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 83
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 122

    (34) auxEscritura1 -> auxEscritura2 ambAuxEscritura1 .

    RPAREN          reduce using rule 34 (auxEscritura1 -> auxEscritura2 ambAuxEscritura1 .)


state 123

    (47) condicion -> IF LPAREN expresion RPAREN . bloque auxCondicion
    (21) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 32

    bloque                         shift and go to state 144

state 124

    (31) auxAsignacion1 -> LBRACKET exp RBRACKET .

    EQUALA          reduce using rule 31 (auxAsignacion1 -> LBRACKET exp RBRACKET .)


state 125

    (30) asignacion -> ID auxAsignacion1 EQUALA exp . SEMICOLON

    SEMICOLON       shift and go to state 145


state 126

    (91) auxArgumentos1 -> exp ambAuxArgumentos1 .

    RPAREN          reduce using rule 91 (auxArgumentos1 -> exp ambAuxArgumentos1 .)


state 127

    (92) ambAuxArgumentos1 -> COMMA . auxArgumentos1
    (91) auxArgumentos1 -> . exp ambAuxArgumentos1
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 90
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    auxArgumentos1                 shift and go to state 146
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 128

    (86) llamada -> ID LPAREN auxLlamada RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 147


state 129

    (7) auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON auxVar1 .

    VAR             reduce using rule 7 (auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON auxVar1 .)
    FUNCTION        reduce using rule 7 (auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON auxVar1 .)
    MAIN            reduce using rule 7 (auxVar1 -> idVars COLON tipo addTypeGlobal SEMICOLON auxVar1 .)


state 130

    (82) auxParametros -> tipo ID ambAuxParametros .

    RPAREN          reduce using rule 82 (auxParametros -> tipo ID ambAuxParametros .)


state 131

    (83) ambAuxParametros -> COMMA . auxParametros
    (82) auxParametros -> . tipo ID ambAuxParametros
    (14) tipo -> . INT ambAuxTipo1
    (15) tipo -> . BOOL ambAuxTipo1
    (16) tipo -> . STRING ambAuxTipo1
    (17) tipo -> . FLOAT ambAuxTipo1
    (18) tipo -> . CHAR ambAuxTipo1

    INT             shift and go to state 16
    BOOL            shift and go to state 19
    STRING          shift and go to state 14
    FLOAT           shift and go to state 17
    CHAR            shift and go to state 18

    tipo                           shift and go to state 67
    auxParametros                  shift and go to state 148

state 132

    (77) funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque .

    FUNCTION        reduce using rule 77 (funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque .)
    MAIN            reduce using rule 77 (funcion -> FUNCTION tipo ID addProcDirectoryFunc LPAREN auxFunction RPAREN bloque .)


state 133

    (94) lectura -> READ LPAREN ID RPAREN SEMICOLON .

    ID              reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    IF              reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    PRINT           reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    READ            reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)
    RBRACE          reduce using rule 94 (lectura -> READ LPAREN ID RPAREN SEMICOLON .)


state 134

    (85) ciclo -> WHILE LPAREN expresion RPAREN bloque .

    ID              reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)
    IF              reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)
    PRINT           reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)
    READ            reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)
    WHILE           reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)
    RBRACE          reduce using rule 85 (ciclo -> WHILE LPAREN expresion RPAREN bloque .)


state 135

    (62) factor -> LPAREN exp RPAREN .

    MULTI           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    GTHAN           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    LTHAN           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    NOTEQUAL        reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    GETHAN          reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    LETHAN          reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 62 (factor -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 62 (factor -> LPAREN exp RPAREN .)


state 136

    (72) auxVarcte -> LPAREN . exp RPAREN
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 149
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 137

    (73) auxVarcte -> LBRACKET . exp LBRACKET
    (50) exp -> . cicloExp
    (51) cicloExp -> . termino ambExp
    (56) termino -> . cicloTermino
    (57) cicloTermino -> . factor ambCicloTermino
    (62) factor -> . LPAREN exp RPAREN
    (63) factor -> . auxFactor varcte
    (64) auxFactor -> . auxExp
    (65) auxFactor -> .
    (54) auxExp -> . PLUS
    (55) auxExp -> . MINUS

    LPAREN          shift and go to state 73
    ID              reduce using rule 65 (auxFactor -> .)
    CTEINT          reduce using rule 65 (auxFactor -> .)
    CTEFLOAT        reduce using rule 65 (auxFactor -> .)
    CTECHAR         reduce using rule 65 (auxFactor -> .)
    CTEBOOL         reduce using rule 65 (auxFactor -> .)
    CTESTRING       reduce using rule 65 (auxFactor -> .)
    PLUS            shift and go to state 76
    MINUS           shift and go to state 80

    auxExp                         shift and go to state 74
    termino                        shift and go to state 77
    exp                            shift and go to state 150
    factor                         shift and go to state 79
    auxFactor                      shift and go to state 75
    cicloExp                       shift and go to state 81
    cicloTermino                   shift and go to state 82

state 138

    (66) varcte -> ID auxVarcte .

    MULTI           reduce using rule 66 (varcte -> ID auxVarcte .)
    DIVIDE          reduce using rule 66 (varcte -> ID auxVarcte .)
    PLUS            reduce using rule 66 (varcte -> ID auxVarcte .)
    MINUS           reduce using rule 66 (varcte -> ID auxVarcte .)
    GTHAN           reduce using rule 66 (varcte -> ID auxVarcte .)
    LTHAN           reduce using rule 66 (varcte -> ID auxVarcte .)
    NOTEQUAL        reduce using rule 66 (varcte -> ID auxVarcte .)
    GETHAN          reduce using rule 66 (varcte -> ID auxVarcte .)
    LETHAN          reduce using rule 66 (varcte -> ID auxVarcte .)
    EQUAL           reduce using rule 66 (varcte -> ID auxVarcte .)
    COMMA           reduce using rule 66 (varcte -> ID auxVarcte .)
    RPAREN          reduce using rule 66 (varcte -> ID auxVarcte .)
    RBRACKET        reduce using rule 66 (varcte -> ID auxVarcte .)
    SEMICOLON       reduce using rule 66 (varcte -> ID auxVarcte .)
    LBRACKET        reduce using rule 66 (varcte -> ID auxVarcte .)


state 139

    (52) ambExp -> auxExp cicloExp .

    GTHAN           reduce using rule 52 (ambExp -> auxExp cicloExp .)
    LTHAN           reduce using rule 52 (ambExp -> auxExp cicloExp .)
    NOTEQUAL        reduce using rule 52 (ambExp -> auxExp cicloExp .)
    GETHAN          reduce using rule 52 (ambExp -> auxExp cicloExp .)
    LETHAN          reduce using rule 52 (ambExp -> auxExp cicloExp .)
    EQUAL           reduce using rule 52 (ambExp -> auxExp cicloExp .)
    COMMA           reduce using rule 52 (ambExp -> auxExp cicloExp .)
    RPAREN          reduce using rule 52 (ambExp -> auxExp cicloExp .)
    RBRACKET        reduce using rule 52 (ambExp -> auxExp cicloExp .)
    SEMICOLON       reduce using rule 52 (ambExp -> auxExp cicloExp .)
    LBRACKET        reduce using rule 52 (ambExp -> auxExp cicloExp .)


state 140

    (39) expresion -> exp auxExpresion exp .

    RPAREN          reduce using rule 39 (expresion -> exp auxExpresion exp .)


state 141

    (58) ambCicloTermino -> auxTermino cicloTermino .

    PLUS            reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    MINUS           reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    GTHAN           reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    LTHAN           reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    NOTEQUAL        reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    GETHAN          reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    LETHAN          reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    EQUAL           reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    COMMA           reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    RPAREN          reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    RBRACKET        reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    SEMICOLON       reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)
    LBRACKET        reduce using rule 58 (ambCicloTermino -> auxTermino cicloTermino .)


state 142

    (33) escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .

    ID              reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    IF              reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    PRINT           reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    READ            reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    WHILE           reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)
    RBRACE          reduce using rule 33 (escritura -> PRINT LPAREN auxEscritura1 RPAREN SEMICOLON .)


state 143

    (35) ambAuxEscritura1 -> COMMA auxEscritura1 .

    RPAREN          reduce using rule 35 (ambAuxEscritura1 -> COMMA auxEscritura1 .)


state 144

    (47) condicion -> IF LPAREN expresion RPAREN bloque . auxCondicion
    (48) auxCondicion -> . ELSE bloque
    (49) auxCondicion -> .

    ELSE            shift and go to state 151
    ID              reduce using rule 49 (auxCondicion -> .)
    IF              reduce using rule 49 (auxCondicion -> .)
    PRINT           reduce using rule 49 (auxCondicion -> .)
    READ            reduce using rule 49 (auxCondicion -> .)
    WHILE           reduce using rule 49 (auxCondicion -> .)
    RBRACE          reduce using rule 49 (auxCondicion -> .)

    auxCondicion                   shift and go to state 152

state 145

    (30) asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .

    ID              reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    IF              reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    PRINT           reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    READ            reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    WHILE           reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)
    RBRACE          reduce using rule 30 (asignacion -> ID auxAsignacion1 EQUALA exp SEMICOLON .)


state 146

    (92) ambAuxArgumentos1 -> COMMA auxArgumentos1 .

    RPAREN          reduce using rule 92 (ambAuxArgumentos1 -> COMMA auxArgumentos1 .)


state 147

    (86) llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .

    ID              reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    IF              reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    PRINT           reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    READ            reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    WHILE           reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)
    RBRACE          reduce using rule 86 (llamada -> ID LPAREN auxLlamada RPAREN SEMICOLON .)


state 148

    (83) ambAuxParametros -> COMMA auxParametros .

    RPAREN          reduce using rule 83 (ambAuxParametros -> COMMA auxParametros .)


state 149

    (72) auxVarcte -> LPAREN exp . RPAREN

    RPAREN          shift and go to state 153


state 150

    (73) auxVarcte -> LBRACKET exp . LBRACKET

    LBRACKET        shift and go to state 154


state 151

    (48) auxCondicion -> ELSE . bloque
    (21) bloque -> . LBRACE cicloBloque RBRACE

    LBRACE          shift and go to state 32

    bloque                         shift and go to state 155

state 152

    (47) condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .

    ID              reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)
    IF              reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)
    PRINT           reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)
    READ            reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)
    WHILE           reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)
    RBRACE          reduce using rule 47 (condicion -> IF LPAREN expresion RPAREN bloque auxCondicion .)


state 153

    (72) auxVarcte -> LPAREN exp RPAREN .

    MULTI           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    DIVIDE          reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    PLUS            reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    MINUS           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    GTHAN           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    LTHAN           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    NOTEQUAL        reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    GETHAN          reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    LETHAN          reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    EQUAL           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    RPAREN          reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 72 (auxVarcte -> LPAREN exp RPAREN .)


state 154

    (73) auxVarcte -> LBRACKET exp LBRACKET .

    MULTI           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    DIVIDE          reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    PLUS            reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    MINUS           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    GTHAN           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    LTHAN           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    NOTEQUAL        reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    GETHAN          reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    LETHAN          reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    EQUAL           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    COMMA           reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    RPAREN          reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    RBRACKET        reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    SEMICOLON       reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)
    LBRACKET        reduce using rule 73 (auxVarcte -> LBRACKET exp LBRACKET .)


state 155

    (48) auxCondicion -> ELSE bloque .

    ID              reduce using rule 48 (auxCondicion -> ELSE bloque .)
    IF              reduce using rule 48 (auxCondicion -> ELSE bloque .)
    PRINT           reduce using rule 48 (auxCondicion -> ELSE bloque .)
    READ            reduce using rule 48 (auxCondicion -> ELSE bloque .)
    WHILE           reduce using rule 48 (auxCondicion -> ELSE bloque .)
    RBRACE          reduce using rule 48 (auxCondicion -> ELSE bloque .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CTESTRING in state 58 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 106 resolved as shift
WARNING: shift/reduce conflict for CTESTRING in state 121 resolved as shift
WARNING: reduce/reduce conflict in state 64 resolved using rule (auxLlamada -> <empty>)
WARNING: rejected rule (argumentos -> <empty>) in state 64
WARNING: Rule (argumentos -> <empty>) is never reduced
